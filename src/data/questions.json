[
  {
    "id": 1,
    "question": "What is the difference between <code>let</code>, <code>const</code>, and <code>var</code> in JavaScript?",
    "answer": "<p>The main differences between <code>let</code>, <code>const</code>, and <code>var</code> are:</p><ul><li><strong>var</strong>: Function-scoped, hoisted, can be redeclared</li><li><strong>let</strong>: Block-scoped, hoisted but not initialized, cannot be redeclared</li><li><strong>const</strong>: Block-scoped, must be initialized, cannot be reassigned</li></ul><pre><code>var x = 1;\nlet y = 2;\nconst z = 3;\n\nvar x = 10;\n// let y = 20;\n// z = 30;</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 2,
    "question": "What is React?",
    "answer": "<p>React is a JavaScript library used for building user interfaces, especially single-page applications where content updates without refreshing the page.</p><pre><code>function App() {\n  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 3,
    "question": "What are components in React?",
    "answer": "<p>Components are like building blocks of a React app. They are reusable pieces of code that return HTML (JSX).</p><ul><li><strong>Functional components</strong></li><li><strong>Class components</strong></li></ul><pre><code>function Welcome() {\n  return &lt;h2&gt;Welcome to React!&lt;/h2&gt;;\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 4,
    "question": "What is JSX?",
    "answer": "<p>JSX stands for JavaScript XML. It allows you to write HTML inside JavaScript.</p><pre><code>const element = &lt;h1&gt;Hello JSX!&lt;/h1&gt;;</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 5,
    "question": "What is the props and state?",
    "answer": "<p>In <strong>React</strong>, <code>props</code> and <code>state</code> are two core concepts used to manage and pass data in components.</p><h4>props</h4><p>Props are used to pass data from parent to child components.</p><p><strong>Key points:</strong></p><ul><li>Read-only (immutable inside the component receiving them)</li><li>Passed from outside the component</li><li>Used to configure a component</li></ul><pre><code>function App() {\n  return &lt;Welcome name=\"Jimit\" /&gt;;\n}\n\nfunction Welcome(props) {\n  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;\n}</code></pre><h4>state</h4><p><strong>State</strong> is used to <strong>manage data inside a component</strong> that can change over time.</p><p><strong>Key points:</strong></p><ul><li>Mutable (can be updated using useState in functional components)</li><li>Managed inside the component</li><li>Used for interactive or dynamic data</li></ul><pre><code>import { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    &lt;&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 6,
    "question": "What is useState?",
    "answer": "<p><code>useState</code> is a <strong>React Hook</strong> that lets you add <strong>state</strong> to a functional component.</p><pre><code>import { useState } from 'react';\n\nfunction Example() {\n  const [name, setName] = useState(\"John\");\n  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 7,
    "question": "What is useEffect?",
    "answer": "<p><code>useEffect</code> is a hook that lets you perform <strong>side effects</strong> (like data fetching, timers) in functional components.</p><pre><code>import { useEffect } from 'react';\n\nfunction Example() {\n  useEffect(() =&gt; {\n    console.log(\"Component mounted!\");\n    return () =&gt; {\n      console.log(\"Component will unmount!\");\n    };\n  }, []);\n  return &lt;div&gt;Example Component&lt;/div&gt;;\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 8,
    "question": "What is the virtual DOM?",
    "answer": "<p>Virtual DOM is a <strong>lightweight copy</strong> of the real DOM. React uses it to <strong>optimize updates</strong>. It compares changes (called <strong>diffing</strong>) and updates only the part that changed.</p>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 9,
    "question": "What is the difference between controlled and uncontrolled components?",
    "answer": "<p><strong>Controlled Component:</strong> React handles the form input.</p><pre><code>function ControlledForm() {\n  const [input, setInput] = useState(\"\");\n  return &lt;input value={input} onChange={e =&gt; setInput(e.target.value)} /&gt;;\n}</code></pre><p><strong>Uncontrolled Component:</strong> DOM handles the form input using <code>ref</code>.</p><pre><code>function UncontrolledForm() {\n  const inputRef = useRef();\n  const handleSubmit = () =&gt; {\n    alert(inputRef.current.value);\n  };\n  return (\n    &lt;&gt;\n      &lt;input type=\"text\" ref={inputRef} /&gt;\n      &lt;button onClick={handleSubmit}&gt;Submit&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 10,
    "question": "What are keys in React?",
    "answer": "<p>Keys help React identify which items in a list are changed or removed. They should be <strong>unique</strong>.</p><pre><code>function TodoList() {\n  const items = [\n    { id: 1, text: 'Learn React' },\n    { id: 2, text: 'Build an app' }\n  ];\n  return (\n    &lt;ul&gt;\n      {items.map(item =&gt; (\n        &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 11,
    "question": "What is lifting state up?",
    "answer": "<p>When <strong>two components need to share data</strong>, the state is moved to their <strong>common parent</strong>.</p>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 12,
    "question": "What is React Router?",
    "answer": "<p>React Router allows navigation between different pages in a React app without reloading the page.</p><pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 13,
    "question": "What is Context API?",
    "answer": "<p>Context API lets you pass data deeply through the component tree without manually passing props at every level.</p><pre><code>import React, { createContext, useContext, useState } from 'react';\n\nconst ThemeContext = createContext();\n\nfunction App() {\n  const [theme, setTheme] = useState('light');\n  return (\n    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;\n      &lt;Toolbar /&gt;\n    &lt;/ThemeContext.Provider&gt;\n  );\n}\n\nfunction Toolbar() {\n  return (\n    &lt;div&gt;\n      &lt;ThemedButton /&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction ThemedButton() {\n  const { theme, setTheme } = useContext(ThemeContext);\n  return (\n    &lt;button\n      onClick={() =&gt; setTheme(theme === 'light' ? 'dark' : 'light')}\n      style={{\n        background: theme === 'light' ? '#fff' : '#333',\n        color: theme === 'light' ? '#000' : '#fff'\n      }}\n    &gt;\n      Current theme: {theme}\n    &lt;/button&gt;\n  );\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 14,
    "question": "What are fragments in React?",
    "answer": "<p>Fragments let you return multiple elements without adding extra DOM nodes.</p><pre><code>&lt;&gt;\n  &lt;h1&gt;Title&lt;/h1&gt;\n  &lt;p&gt;Description&lt;/p&gt;\n&lt;/&gt;</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 15,
    "question": "What is the useEffect and useLayoutEffect?",
    "answer": "<p>Both are <strong>React hooks</strong> used for <strong>side effects</strong> (like fetching data, DOM updates, timers), but they run at <strong>different times</strong> in the component lifecycle.</p><h2><code>useEffect</code></h2><blockquote><p>Runs <strong>after the component renders</strong> and <strong>after the DOM is painted</strong>.</p></blockquote><p>Common use cases:</p><ul><li>Fetching data</li><li>Subscribing to events</li><li>Setting up timers</li></ul><pre><code>import { useEffect, useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n  useEffect(() =&gt; {\n    console.log('useEffect: DOM updated');\n  }, [count]);\n  return (\n    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;\n      Clicked {count}\n    &lt;/button&gt;\n  );\n}</code></pre><h2><code>useLayoutEffect</code></h2><blockquote><p>Runs <strong>after rendering</strong> but <strong>before the DOM is painted</strong> on the screen.</p></blockquote><p>Use it when:</p><ul><li>You need to <strong>measure layout</strong> or <strong>make DOM changes</strong> that must <strong>block painting</strong> (e.g. scroll, size, position).</li></ul><pre><code>import { useLayoutEffect, useRef } from 'react';\n\nfunction LayoutExample() {\n  const boxRef = useRef();\n  useLayoutEffect(() =&gt; {\n    boxRef.current.style.backgroundColor = 'yellow';\n    console.log('useLayoutEffect: DOM updated before paint');\n  }, []);\n  return &lt;div ref={boxRef}&gt;Hello&lt;/div&gt;;\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 16,
    "question": "What is useRef?",
    "answer": "<p><code>useRef</code> is a hook to <strong>store a reference</strong> to a DOM element or a value that persists between renders.</p><pre><code>function Form() {\n  const inputRef = React.useRef();\n  const handleSubmit = () =&gt; {\n    alert(inputRef.current.value);\n  };\n  return (\n    &lt;&gt;\n      &lt;input type=\"text\" ref={inputRef} /&gt;\n      &lt;button onClick={handleSubmit}&gt;Submit&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 17,
    "question": "What is React.memo?",
    "answer": "<p><code>React.memo</code> is used to <strong>prevent unnecessary re-renders</strong> of a component if its props haven't changed.</p><pre><code>const MyComponent = React.memo(function MyComponent({ name }) {\n  return &lt;p&gt;{name}&lt;/p&gt;;\n});</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 18,
    "question": "What is the difference between useCallback and useMemo?",
    "answer": "<p>Both <code>useCallback</code> and <code>useMemo</code> are <strong>performance optimization hooks</strong> in React. They help avoid unnecessary re-renders or recalculations.</p><h2><code>useCallback</code></h2><blockquote><p><code>useCallback</code> <strong>memoizes a function</strong> — returns the <strong>same function instance</strong> unless its dependencies change.</p></blockquote><p><strong>Use when:</strong> You pass functions to child components and want to <strong>prevent re-creating them on every render</strong>.</p><pre><code>import { useCallback, useState } from 'react';\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const handleClick = useCallback(() =&gt; {\n    console.log('Button clicked');\n  }, []);\n  return (\n    &lt;&gt;\n      &lt;Child onClick={handleClick} /&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Re-render Parent&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n\nfunction Child({ onClick }) {\n  console.log('Child rendered');\n  return &lt;button onClick={onClick}&gt;Click me&lt;/button&gt;;\n}</code></pre><h2><code>useMemo</code></h2><blockquote><p><code>useMemo</code> <strong>memoizes a computed value</strong> — avoids <strong>expensive recalculations</strong> on every render.</p></blockquote><p><strong>Use when:</strong> You have <strong>slow calculations</strong> or want to <strong>avoid recalculating derived values</strong> unless dependencies change.</p><pre><code>import { useMemo, useState } from 'react';\n\nfunction ExpensiveComponent() {\n  const [count, setCount] = useState(0);\n  const [other, setOther] = useState(false);\n  const expensiveCalculation = useMemo(() =&gt; {\n    console.log('Calculating...');\n    return count * 2;\n  }, [count]);\n  return (\n    &lt;&gt;\n      &lt;p&gt;Expensive Value: {expensiveCalculation}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increase&lt;/button&gt;\n      &lt;button onClick={() =&gt; setOther(!other)}&gt;Toggle Other&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 19,
    "question": "What is prop drilling and how to avoid it?",
    "answer": "<p>Prop drilling is passing props from parent to child to grandchild, etc., even if only the last one needs it.</p><p><strong>Solution:</strong><br>Use <strong>Context API</strong> or <strong>state management libraries</strong> (like Redux).</p>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 20,
    "question": "What is lazy loading in React?",
    "answer": "<p>Lazy loading means loading components <strong>only when needed</strong> to reduce the initial load time.</p><pre><code>const LazyComponent = React.lazy(() =&gt; import('./MyComponent'));\n\n&lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n  &lt;LazyComponent /&gt;\n&lt;/Suspense&gt;</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 21,
    "question": "What is reconciliation in React?",
    "answer": "<p>Reconciliation is the process where React compares the <strong>virtual DOM</strong> with the <strong>real DOM</strong> and updates only what's changed.</p>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 22,
    "question": "What is the significance of the key prop in lists?",
    "answer": "<p>It helps React <strong>track list items</strong> and update them efficiently without re-rendering the whole list.</p>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 23,
    "question": "What are higher-order components (HOC)?",
    "answer": "<p>HOC is a function that takes a component and <strong>returns a new component</strong> with added functionality.</p><pre><code>function withAuth(Component) {\n  return function EnhancedComponent(props) {\n    return &lt;Component {...props} isAuthenticated={true} /&gt;;\n  };\n}</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 24,
    "question": "What is the purpose of defaultProps?",
    "answer": "<p><code>defaultProps</code> sets <strong>default values</strong> for props if no value is passed.</p><pre><code>function Greet({ name }) {\n  return &lt;h1&gt;Hello, {name}&lt;/h1&gt;;\n}\n\nGreet.defaultProps = {\n  name: \"Guest\"\n};</code></pre>",
    "category": "React",
    "difficulty": "Beginner"
  },
  {
    "id": 25,
    "question": "What is Angular?",
    "answer": "<p>Angular is a front-end web framework made by Google to build <strong>single-page web applications (SPA)</strong> using <strong>HTML, CSS, and TypeScript</strong>.</p>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is a component in Angular?",
    "answer": "<p>A component is the basic building block of an Angular application. It controls a part of the screen called a <strong>view</strong>.</p><pre><code>@Component({\n  selector: 'app-hello',\n  template: '&lt;h1&gt;Hello World!&lt;/h1&gt;'\n})\nexport class HelloComponent { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is a module in Angular?",
    "answer": "<p>A module is a container that holds related components, services, and other modules. Every Angular app has a root module called <code>AppModule</code>.</p><pre><code>@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is data binding?",
    "answer": "<p>Data binding is the connection between the HTML and the component (TypeScript code). It helps keep your UI and logic in sync.</p><p><strong>Types:</strong></p><ul><li><strong>Interpolation</strong> – <code>{{ name }}</code></li><li><strong>Property binding</strong> – <code>[src]=\"imageUrl\"</code></li><li><strong>Event binding</strong> – <code>(click)=\"sayHello()\"</code></li><li><strong>Two-way binding</strong> – <code>[(ngModel)]=\"userInput\"</code></li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is dependency injection?",
    "answer": "<p>Dependency injection is a design pattern used to provide services (like APIs, logic, etc.) to components automatically.</p><pre><code>constructor(private userService: UserService) { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is a service in Angular?",
    "answer": "<p>A service is a class used to write business logic, such as fetching data from an API. It can be shared across multiple components.</p><pre><code>@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  getData() {\n    return this.http.get('/api/data');\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is routing in Angular?",
    "answer": "<p>Routing is how Angular navigates between different pages or views in a single-page app.</p><pre><code>const routes: Routes = [\n  { path: 'home', component: HomeComponent },\n  { path: 'about', component: AboutComponent }\n];</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What are directives?",
    "answer": "<p>Directives are instructions in the template that tell Angular how to render or change elements.</p><p><strong>Types:</strong></p><ul><li><strong>Structural</strong> – <code>*ngIf</code>, <code>*ngFor</code></li><li><strong>Attribute</strong> – <code>[ngClass]</code>, <code>[ngStyle]</code></li><li><strong>Custom</strong> – You can create your own directive.</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the difference between ngIf and ngFor?",
    "answer": "<ul><li><code>*ngIf</code> is used to <strong>show or hide</strong> an element.</li><li><code>*ngFor</code> is used to <strong>loop through a list</strong> and create multiple elements.</li></ul><pre><code>&lt;p *ngIf=\"isLoggedIn\"&gt;Welcome!&lt;/p&gt;\n&lt;ul&gt;\n  &lt;li *ngFor=\"let item of items\"&gt;{{ item }}&lt;/li&gt;\n&lt;/ul&gt;</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is a pipe in Angular?",
    "answer": "<p>Pipes are used to transform data in the template</p><pre><code>&lt;p&gt;{{ birthday | date:'longDate' }}&lt;/p&gt;\n&lt;p&gt;{{ price | currency:'USD' }}&lt;/p&gt;</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the difference between @Input() and @Output()?",
    "answer": "<ul><li><code>@Input()</code> – Pass data <strong>from parent to child</strong> component.</li><li><code>@Output()</code> – Send data <strong>from child to parent</strong> component using <code>EventEmitter</code>.</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is lazy loading?",
    "answer": "<p>Lazy loading means loading a module <strong>only when it's needed</strong>, not at the start. It helps improve performance.</p>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 37,
    "question": "What is Angular CLI?",
    "answer": "<p>Angular CLI is a command-line tool to create and manage Angular apps.</p><p><strong>Example commands:</strong></p><ul><li><code>ng new my-app</code> – create a new app</li><li><code>ng serve</code> – run the app</li><li><code>ng generate component header</code> – create a component</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 38,
    "question": "How do you share data between components?",
    "answer": "<ul><li><strong>Parent to Child</strong> – use <code>@Input()</code></li><li><strong>Child to Parent</strong> – use <code>@Output()</code></li><li><strong>Sibling components</strong> – use a <strong>shared service</strong></li><li><strong>Across app</strong> – use <strong>NgRx</strong> or shared services</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 39,
    "question": "What is Ahead-of-Time (AOT) Compilation?",
    "answer": "<p>Angular offers two types of compilation:</p><ul><li><strong>JIT (Just-in-Time):</strong> Compiles in the browser (during development)</li><li><strong>AOT (Ahead-of-Time):</strong> Compiles during build time (for production)</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 40,
    "question": "What are lifecycle hooks in Angular?",
    "answer": "<p>Lifecycle hooks are special methods Angular calls at different stages of a component's life — from creation to destruction.</p><ul><li><code>constructor</code>When the component is created (used for simple setup)</li><li><code>ngOnChanges()</code>When an input property changes</li><li><code>ngOnInit()</code>After the first <code>ngOnChanges</code> – good for API calls</li><li><code>ngDoCheck()</code>Custom change detection (called often)</li><li><code>ngAfterContentInit()</code>After external content is projected into the component</li><li><code>ngAfterContentChecked()</code>After every check of projected content</li><li><code>ngAfterViewInit()</code>After component view (and child views) are initialized</li><li><code>ngAfterViewChecked()</code>After every check of the component and child views</li><li><code>ngOnDestroy()</code>Just before the component is destroyed – cleanup time</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 41,
    "question": "What is the difference between Observable and Promise?",
    "answer": "<p><strong>Observable</strong></p><ul><li>Can emit <strong>multiple values</strong></li><li>it can be <strong>Cancelable</strong></li><li>its <strong>Lazy </strong>(runs only when subscribed)</li></ul><p><strong>Promise</strong></p><ul><li>Emits <strong>one value</strong> only</li><li>it can not be <strong>Cancelable</strong></li><li>its <strong>Lazy</strong></li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 42,
    "question": "What is the difference between <code>==</code> and <code>===</code>?",
    "answer": "<ul><li><code>==</code> checks value only (loose equality).</li><li><code>===</code> checks value and type (strict equality).</li></ul><pre><code>console.log(5 == '5');  // true\nconsole.log(5 === '5'); // false</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 43,
    "question": "What is hoisting in JavaScript?",
    "answer": "<p>Hoisting means moving variable and function declarations to the top of their scope before code execution.<p><pre><code>console.log(a); // undefined\nvar a = 5;</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  
  {
    "id": 44,
    "question": "What is Angular's change detection?",
    "answer": "<p>Change detection is how Angular keeps track of changes in your app and updates the view. Think of it like a security camera that watches for changes and updates the screen when needed.</p><pre><code>@Component({\n  selector: 'app-counter',\n  template: `\n    &lt;button (click)=\"increment()\"&gt;Count: {{count}}&lt;/button&gt;\n  `\n})\nexport class CounterComponent {\n  count = 0;\n  increment() {\n    this.count++; // Angular automatically updates the view\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 45,
    "question": "What is Angular's HttpClient and how to use it?",
    "answer": "<p>HttpClient is a service for making HTTP requests (like getting data from a server). It's like a messenger that fetches or sends data.</p><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor(private http: HttpClient) {}\n\n  // Get users from server\n  getUsers() {\n    return this.http.get('https://api.example.com/users');\n  }\n\n  // Add a new user\n  addUser(user: any) {\n    return this.http.post('https://api.example.com/users', user);\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 46,
    "question": "What is Angular's async pipe?",
    "answer": "<p>The async pipe automatically handles subscriptions and unsubscriptions for Observables and Promises. It's like having an automatic cleanup crew.</p><pre><code>@Component({\n  selector: 'app-users',\n  template: `\n    &lt;div *ngIf=\"users$ | async as users\"&gt;\n      &lt;ul&gt;\n        &lt;li *ngFor=\"let user of users\"&gt;\n          {{user.name}}\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  `\n})\nexport class UsersComponent {\n  users$ = this.userService.getUsers();\n  constructor(private userService: UserService) {}\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 47,
    "question": "What is Angular's ViewChild and how to use it?",
    "answer": "<p>ViewChild lets you access child components, directives, or DOM elements from your parent component. It's like having a remote control for child elements.</p><pre><code>@Component({\n  selector: 'app-parent',\n  template: `\n    &lt;app-child #childRef&gt;&lt;/app-child&gt;\n    &lt;button (click)=\"callChildMethod()\"&gt;Call Child&lt;/button&gt;\n  `\n})\nexport class ParentComponent {\n  @ViewChild('childRef') child: ChildComponent;\n\n  callChildMethod() {\n    this.child.someMethod(); // Call child's method\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 48,
    "question": "What is Angular's form validation?",
    "answer": "<p>Form validation helps ensure users enter correct data. Angular provides built-in validators and lets you create custom ones.</p><pre><code>@Component({\n  selector: 'app-login',\n  template: `\n    &lt;form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\"&gt;\n      &lt;input formControlName=\"email\" placeholder=\"Email\"&gt;\n      &lt;div *ngIf=\"email.invalid && email.touched\"&gt;\n        Email is required and must be valid\n      &lt;/div&gt;\n\n      &lt;input type=\"password\" formControlName=\"password\"&gt;\n      &lt;div *ngIf=\"password.invalid && password.touched\"&gt;\n        Password must be at least 6 characters\n      &lt;/div&gt;\n\n      &lt;button [disabled]=\"loginForm.invalid\"&gt;Login&lt;/button&gt;\n    &lt;/form&gt;\n  `\n})\nexport class LoginComponent {\n  loginForm = this.fb.group({\n    email: ['', [Validators.required, Validators.email]],\n    password: ['', [Validators.required, Validators.minLength(6)]]\n  });\n\n  constructor(private fb: FormBuilder) {}\n\n  get email() { return this.loginForm.get('email'); }\n  get password() { return this.loginForm.get('password'); }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 49,
    "question": "What are Arrow Functions in ES6?",
    "answer": "<p>Arrow functions are a shorter way to write functions in JavaScript. They make code more concise and handle 'this' differently.</p><pre><code>// Old way\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function way\nconst add = (a, b) => a + b;\n\n// With multiple lines\nconst multiply = (a, b) => {\n  const result = a * b;\n  return result;\n};\n\n// Real-world example with array methods\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num => num * 2);</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 50,
    "question": "What are Template Literals in ES6?",
    "answer": "<p>Template literals allow you to create strings with embedded expressions using backticks (`). They make string concatenation much easier.</p><pre><code>// Old way\nconst name = 'John';\nconst greeting = 'Hello, ' + name + '! Welcome to ' + city + '.';\n\n// Template literal way\nconst greeting = `Hello, ${name}! Welcome to ${city}.`;\n\n// Multi-line strings\nconst email = `\n  Dear ${name},\n  Thank you for your order.\n  Your order number is: ${orderNumber}\n  Best regards,\n  The Team\n`;</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 51,
    "question": "What is Destructuring in ES6?",
    "answer": "<p>Destructuring allows you to extract values from arrays or objects into distinct variables. It makes code cleaner and more readable.</p><pre><code>// Array destructuring\nconst colors = ['red', 'green', 'blue'];\nconst [first, second, third] = colors;\nconsole.log(first); // 'red'\n\n// Object destructuring\nconst person = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nconst { name, age } = person;\nconsole.log(name); // 'John'\n\n// With default values\nconst { country = 'USA' } = person;\n\n// In function parameters\nfunction printUser({ name, age }) {\n  console.log(`${name} is ${age} years old`);\n}</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 52,
    "question": "What are Spread and Rest Operators in ES6?",
    "answer": "<p>The spread (...) operator expands arrays or objects, while the rest operator collects remaining elements into an array.</p><pre><code>// Spread operator with arrays\nconst arr1 = [1, 2, 3];\nconst arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]\n\n// Spread operator with objects\nconst person = { name: 'John', age: 30 };\nconst updatedPerson = { ...person, city: 'New York' };\n\n// Rest operator in function parameters\nfunction sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4)); // 10\n\n// Rest operator in destructuring\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(rest); // [3, 4, 5]</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 53,
    "question": "What are ES6 Classes?",
    "answer": "<p>Classes in ES6 provide a cleaner way to create objects and handle inheritance. They are syntactic sugar over JavaScript's prototype-based inheritance.</p><pre><code>class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} makes a sound.`);\n  }\n}\n\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n\n  fetch() {\n    console.log(`${this.name} fetches the ball.`);\n  }\n}\n\nconst dog = new Dog('Rex');\ndog.speak(); // 'Rex barks.'\ndog.fetch(); // 'Rex fetches the ball.'</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 54,
    "question": "What are ES6 Modules?",
    "answer": "<p>ES6 modules allow you to split your code into separate files and import/export functionality between them.</p><pre><code>// math.js\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\n\nexport default class Calculator {\n  multiply(a, b) {\n    return a * b;\n  }\n}\n\n// main.js\nimport Calculator, { add, subtract } from './math.js';\n\nconst calc = new Calculator();\nconsole.log(add(5, 3)); // 8\nconsole.log(calc.multiply(4, 2)); // 8</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 55,
    "question": "What are Promises in ES6?",
    "answer": "<p>Promises are objects that represent the eventual completion (or failure) of an asynchronous operation. They help handle asynchronous code more elegantly.</p><pre><code>// Creating a promise\nconst fetchData = () => {\n  return new Promise((resolve, reject) => {\n    // Simulating API call\n    setTimeout(() => {\n      const data = { id: 1, name: 'John' };\n      resolve(data);\n      // If error: reject(new Error('Failed to fetch'));\n    }, 1000);\n  });\n};\n\n// Using the promise\nfetchData()\n  .then(data => {\n    console.log('Success:', data);\n  })\n  .catch(error => {\n    console.error('Error:', error);\n  });\n\n// Using async/await (ES7)\nasync function getData() {\n  try {\n    const data = await fetchData();\n    console.log('Success:', data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 56,
    "question": "What are Map and Set in ES6?",
    "answer": "<p>Map and Set are new data structures in ES6. Map is like an object but with any type of keys, and Set stores unique values.</p><pre><code>// Map example\nconst userMap = new Map();\nuserMap.set('name', 'John');\nuserMap.set(1, 'One');\nuserMap.set({ id: 1 }, 'Object key');\n\nconsole.log(userMap.get('name')); // 'John'\nconsole.log(userMap.has(1)); // true\n\n// Set example\nconst numbers = new Set([1, 2, 3, 3, 4, 4]);\nconsole.log(numbers); // Set {1, 2, 3, 4}\n\n// Real-world example: Counting unique visitors\nconst visitors = new Set();\nvisitors.add('user1');\nvisitors.add('user2');\nvisitors.add('user1'); // Duplicate ignored\nconsole.log(visitors.size); // 2</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 57,
    "question": "What are Generators in ES6?",
    "answer": "<p>Generators are functions that can be paused and resumed. They use the function* syntax and yield keyword.</p><pre><code>// Basic generator\nfunction* numberGenerator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3\n\n// Real-world example: Infinite sequence\nfunction* infiniteSequence() {\n  let i = 0;\n  while(true) {\n    yield i++;\n  }\n}\n\nconst infinite = infiniteSequence();\nconsole.log(infinite.next().value); // 0\nconsole.log(infinite.next().value); // 1\nconsole.log(infinite.next().value); // 2</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 58,
    "question": "What are Array Methods in ES6?",
    "answer": "<p>ES6 introduced several powerful array methods for data manipulation. Here are the most commonly used ones:</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\n// map: transform each element\nconst doubled = numbers.map(num => num * 2);\n// [2, 4, 6, 8, 10]\n\n// filter: select elements that match a condition\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\n// [2, 4]\n\n// reduce: combine elements into a single value\nconst sum = numbers.reduce((total, num) => total + num, 0);\n// 15\n\n// find: get first matching element\nconst firstEven = numbers.find(num => num % 2 === 0);\n// 2\n\n// some: check if any element matches\nconst hasEven = numbers.some(num => num % 2 === 0);\n// true\n\n// every: check if all elements match\nconst allPositive = numbers.every(num => num > 0);\n// true</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 59,
    "question": "What is the Symbol type in ES6?",
    "answer": "<p>Symbol is a new primitive type in ES6 that creates unique identifiers. Symbols are often used as object property keys.</p><pre><code>// Creating symbols\nconst sym1 = Symbol('description');\nconst sym2 = Symbol('description');\nconsole.log(sym1 === sym2); // false\n\n// Using symbols as object keys\nconst user = {\n  [Symbol('id')]: 1,\n  name: 'John'\n};\n\n// Well-known symbols\nconst numbers = [1, 2, 3];\nnumbers[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n// Real-world example: Private properties\nconst privateData = Symbol('privateData');\nclass User {\n  constructor() {\n    this[privateData] = 'secret';\n  }\n  getPrivateData() {\n    return this[privateData];\n  }\n}</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 60,
    "question": "What are Object Methods in ES6?",
    "answer": "<p>ES6 added several useful methods for working with objects. Here are the most important ones:</p><pre><code>const person = { name: 'John', age: 30 };\n\n// Object.assign: copy properties\nconst newPerson = Object.assign({}, person, { city: 'New York' });\n\n// Object.keys: get property names\nconst keys = Object.keys(person); // ['name', 'age']\n\n// Object.values: get property values\nconst values = Object.values(person); // ['John', 30]\n\n// Object.entries: get key-value pairs\nconst entries = Object.entries(person);\n// [['name', 'John'], ['age', 30]]\n\n// Object.freeze: make object immutable\nconst frozen = Object.freeze(person);\n\n// Real-world example: Merging objects\nconst defaults = { theme: 'light', language: 'en' };\nconst userSettings = { theme: 'dark' };\nconst settings = Object.assign({}, defaults, userSettings);\n// { theme: 'dark', language: 'en' }</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 61,
    "question": "What is the Proxy object in ES6?",
    "answer": "<p>Proxy allows you to create a wrapper around an object that can intercept and customize operations like property lookup, assignment, etc.</p><pre><code>// Basic proxy\nconst handler = {\n  get: function(target, prop) {\n    return prop in target ? target[prop] : 'Not found';\n  },\n  set: function(target, prop, value) {\n    if (prop === 'age' && value < 0) {\n      throw new Error('Age cannot be negative');\n    }\n    target[prop] = value;\n    return true;\n  }\n};\n\nconst person = new Proxy({}, handler);\nperson.name = 'John';\nconsole.log(person.name); // 'John'\nconsole.log(person.unknown); // 'Not found'\n\n// Real-world example: Validation proxy\nconst userProxy = new Proxy({}, {\n  set: function(target, prop, value) {\n    if (prop === 'email' && !value.includes('@')) {\n      throw new Error('Invalid email');\n    }\n    target[prop] = value;\n    return true;\n  }\n});</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 62,
    "question": "What is the Reflect object in ES6?",
    "answer": "<p>Reflect is a built-in object that provides methods for interceptable JavaScript operations. It's often used with Proxy.</p><pre><code>// Basic Reflect usage\nconst user = { name: 'John' };\n\n// Getting property\nconsole.log(Reflect.get(user, 'name')); // 'John'\n\n// Setting property\nReflect.set(user, 'age', 30);\n\n// Checking if property exists\nconsole.log(Reflect.has(user, 'name')); // true\n\n// Deleting property\nReflect.deleteProperty(user, 'age');\n\n// Real-world example: Dynamic property access\nfunction getProperty(obj, prop) {\n  if (Reflect.has(obj, prop)) {\n    return Reflect.get(obj, prop);\n  }\n  return undefined;\n}\n\nconst result = getProperty(user, 'name'); // 'John'</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 63,
    "question": "What is Async/Await in ES7?",
    "answer": "<p>Async/await is a way to write asynchronous code that looks like synchronous code. It makes promises easier to work with.</p><pre><code>// Using promises\nfunction fetchUserData(userId) {\n  return fetch(`https://api.example.com/users/${userId}`)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    })\n    .then(user => {\n      return fetch(`https://api.example.com/users/${userId}/posts`)\n        .then(response => response.json())\n        .then(posts => {\n          return { user, posts };\n        });\n    })\n    .catch(error => {\n      console.error('Error:', error);\n      throw error;\n    });\n}\n\n// Using async/await\nasync function fetchUserData(userId) {\n  try {\n    const userResponse = await fetch(`https://api.example.com/users/${userId}`);\n    if (!userResponse.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const user = await userResponse.json();\n\n    const postsResponse = await fetch(`https://api.example.com/users/${userId}/posts`);\n    const posts = await postsResponse.json();\n\n    return { user, posts };\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n\n// Real-world example: Multiple API calls\nasync function getUserData(userId) {\n  const user = await fetchUserData(userId);\n  const posts = await fetchUserPosts(userId);\n  const comments = await fetchUserComments(userId);\n  return { user, posts, comments };\n}</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 64,
    "question": "What is Optional Chaining (?.) in ES2020?",
    "answer": "<p>Optional chaining is a way to safely access nested object properties without having to check if each level exists.</p><pre><code>// Old way\nconst street = user && user.address && user.address.street;\n\n// With optional chaining\nconst street = user?.address?.street;\n\n// With function calls\nconst result = user?.getName?.();\n\n// With array access\nconst firstItem = array?.[0];\n\n// Real-world example: API response\nconst userData = {\n  user: {\n    profile: {\n      name: 'John'\n    }\n  }\n};\n\nconsole.log(userData?.user?.profile?.name); // 'John'\nconsole.log(userData?.user?.settings?.theme); // undefined</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 65,
    "question": "What is Nullish Coalescing (??) in ES2020?",
    "answer": "<p>Nullish coalescing is an operator that returns the right-hand operand when the left-hand operand is null or undefined.</p><pre><code>// Old way\nconst value = someValue !== null && someValue !== undefined ? someValue : defaultValue;\n\n// With nullish coalescing\nconst value = someValue ?? defaultValue;\n\n// Real-world examples\nconst user = {\n  name: 'John',\n  age: 0,\n  email: null\n};\n\nconsole.log(user.name ?? 'Anonymous'); // 'John'\nconsole.log(user.age ?? 18); // 0 (because 0 is not null/undefined)\nconsole.log(user.email ?? 'no-email@example.com'); // 'no-email@example.com'\n\n// With optional chaining\nconst theme = user?.settings?.theme ?? 'light';</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 66,
    "question": "What is Dynamic Import in ES6?",
    "answer": "<p>Dynamic import allows you to load modules on demand, which is useful for code splitting and lazy loading.</p><pre><code>// Static import\nimport { add } from './math.js';\n\n// Dynamic import\nasync function loadModule() {\n  try {\n    const module = await import('./math.js');\n    console.log(module.add(2, 3));\n  } catch (error) {\n    console.error('Failed to load module:', error);\n  }\n}\n\n// Real-world example: Lazy loading components\nasync function loadComponent(componentName) {\n  const component = await import(`./components/${componentName}.js`);\n  return component.default;\n}\n\n// Usage in React-like environment\nasync function renderComponent() {\n  const Button = await loadComponent('Button');\n  return &lt;Button /&gt;;\n}</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 67,
    "question": "What is BigInt in ES2020?",
    "answer": "<p>BigInt is a new numeric primitive that can represent integers of arbitrary precision, useful for working with very large numbers.</p><pre><code>// Creating BigInt\nconst bigNumber = 9007199254740991n; // Note the 'n' suffix\nconst anotherBig = BigInt('9007199254740991');\n\n// Operations with BigInt\nconst sum = bigNumber + 1n;\nconst product = bigNumber * 2n;\n\n// Real-world example: Working with large numbers\nfunction calculateFactorial(n) {\n  let result = 1n;\n  for (let i = 2n; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(calculateFactorial(20n)); // 2432902008176640000n\n\n// Converting between Number and BigInt\nconst regularNumber = 123;\nconst bigIntNumber = BigInt(regularNumber);\nconst backToNumber = Number(bigIntNumber);</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 68,
    "question": "What are String Methods in ES6?",
    "answer": "<p>ES6 introduced several useful string methods for searching and manipulating strings.</p><pre><code>const text = 'Hello, World!';\n\n// startsWith: check if string starts with a pattern\nconsole.log(text.startsWith('Hello')); // true\n\n// endsWith: check if string ends with a pattern\nconsole.log(text.endsWith('!')); // true\n\n// includes: check if string contains a pattern\nconsole.log(text.includes('World')); // true\n\n// repeat: repeat string multiple times\nconsole.log('ha'.repeat(3)); // 'hahaha'\n\n// padStart/padEnd: add padding to string\nconsole.log('5'.padStart(3, '0')); // '005'\nconsole.log('5'.padEnd(3, '0')); // '500'\n\n// Real-world example: Formatting\nfunction formatPhoneNumber(number) {\n  return number.padStart(10, '0').replace(/(\\d{3})(\\d{3})(\\d{4})/, '($1) $2-$3');\n}\n\nconsole.log(formatPhoneNumber('1234567890')); // '(123) 456-7890'</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 69,
    "question": "What are Array Methods in ES6+?",
    "answer": "<p>ES6 and later versions added more powerful array methods for data manipulation.</p><pre><code>const numbers = [1, 2, 3, 4, 5];\n\n// includes: check if array contains a value\nconsole.log(numbers.includes(3)); // true\n\n// flat: flatten nested arrays\nconst nested = [1, [2, 3], [4, [5, 6]]];\nconsole.log(nested.flat()); // [1, 2, 3, 4, [5, 6]]\nconsole.log(nested.flat(2)); // [1, 2, 3, 4, 5, 6]\n\n// flatMap: map and flatten in one step\nconst sentences = ['Hello world', 'Good morning'];\nconst words = sentences.flatMap(sentence => sentence.split(' '));\n// ['Hello', 'world', 'Good', 'morning']\n\n// Real-world example: Data processing\nconst users = [\n  { name: 'John', hobbies: ['reading', 'gaming'] },\n  { name: 'Jane', hobbies: ['painting', 'dancing'] }\n];\n\nconst allHobbies = users.flatMap(user => user.hobbies);\n// ['reading', 'gaming', 'painting', 'dancing']</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 70,
    "question": "What is the difference between Promises and Async/Await?",
    "answer": "<p>Promises and Async/Await are both ways to handle asynchronous operations in JavaScript, but they have different syntax and use cases.</p><h3>Key Differences:</h3><ul><li>Promises use .then() chains, while Async/Await uses a more synchronous-looking syntax</li><li>Async/Await is built on top of Promises</li><li>Async/Await makes error handling easier with try/catch</li><li>Async/Await is generally more readable and maintainable</li></ul><h3>Promise Example:</h3><pre><code>// Using Promises\nfunction fetchUserData(userId) {\n  return fetch(`https://api.example.com/users/${userId}`)\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    })\n    .then(user => {\n      return fetch(`https://api.example.com/users/${userId}/posts`)\n        .then(response => response.json())\n        .then(posts => {\n          return { user, posts };\n        });\n    })\n    .catch(error => {\n      console.error('Error:', error);\n      throw error;\n    });\n}\n\n// Using the Promise\nfetchUserData(123)\n  .then(data => {\n    console.log('User:', data.user);\n    console.log('Posts:', data.posts);\n  })\n  .catch(error => {\n    console.error('Failed:', error);\n  });</code></pre><h3>Async/Await Example:</h3><pre><code>// Using Async/Await\nasync function fetchUserData(userId) {\n  try {\n    const userResponse = await fetch(`https://api.example.com/users/${userId}`);\n    if (!userResponse.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const user = await userResponse.json();\n\n    const postsResponse = await fetch(`https://api.example.com/users/${userId}/posts`);\n    const posts = await postsResponse.json();\n\n    return { user, posts };\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n\n// Using the Async function\nasync function displayUserData() {\n  try {\n    const data = await fetchUserData(123);\n    console.log('User:', data.user);\n    console.log('Posts:', data.posts);\n  } catch (error) {\n    console.error('Failed:', error);\n  }\n}</code></pre><h3>Real-world Example: Multiple API Calls</h3><pre><code>// Using Promises\nfunction getOrderDetails(orderId) {\n  return fetch(`/api/orders/${orderId}`)\n    .then(response => response.json())\n    .then(order => {\n      return Promise.all([\n        fetch(`/api/users/${order.userId}`).then(r => r.json()),\n        fetch(`/api/products/${order.productId}`).then(r => r.json())\n      ]).then(([user, product]) => {\n        return { order, user, product };\n      });\n    });\n}\n\n// Using Async/Await\nasync function getOrderDetails(orderId) {\n  const order = await fetch(`/api/orders/${orderId}`).then(r => r.json());\n  const [user, product] = await Promise.all([\n    fetch(`/api/users/${order.userId}`).then(r => r.json()),\n    fetch(`/api/products/${order.productId}`).then(r => r.json())\n  ]);\n  return { order, user, product };\n}</code></pre><h3>When to Use Each:</h3><ul><li><strong>Use Promises when:</strong><ul><li>You need to handle multiple asynchronous operations in parallel</li><li>You're working with older code or libraries that use Promises</li><li>You need to chain multiple operations</li></ul></li><li><strong>Use Async/Await when:</strong><ul><li>You want more readable and maintainable code</li><li>You need to handle errors with try/catch</li><li>You're writing new code that doesn't need to support older browsers</li></ul></li></ul>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 71,
    "question": "What is the difference between SQL and NoSQL databases?",
    "answer": "<p>SQL and NoSQL databases differ in their data structure, scalability, and use cases.</p><h3>SQL (MySQL, PostgreSQL)</h3><ul><li>Uses tables with rows and columns</li><li>Requires predefined schema</li><li>Better for complex queries and relationships</li><li>ACID compliant</li></ul><h3>NoSQL (MongoDB)</h3><ul><li>Uses collections of documents</li><li>Schema-less and flexible</li><li>Better for scalability and big data</li><li>Eventually consistent</li></ul><h3>Example: Storing User Data</h3><pre><code>// SQL (MySQL/PostgreSQL)\nCREATE TABLE users (\n  id INT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100),\n  created_at TIMESTAMP\n);\n\nINSERT INTO users (id, name, email) VALUES (1, 'John', 'john@example.com');\n\n// NoSQL (MongoDB)\ndb.users.insertOne({\n  name: 'John',\n  email: 'john@example.com',\n  created_at: new Date()\n});</code></pre>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 72,
    "question": "What are Indexes in Databases?",
    "answer": "<p>Indexes are data structures that improve the speed of data retrieval operations. Think of them like a book's index - instead of reading the whole book to find something, you can quickly look it up in the index.</p><h3>MySQL/PostgreSQL Index Example:</h3><pre><code>-- Creating an index\nCREATE INDEX idx_email ON users(email);\n\n-- Composite index\nCREATE INDEX idx_name_email ON users(name, email);\n\n-- Using index in query\nSELECT * FROM users WHERE email = 'john@example.com'; -- Uses index</code></pre><h3>MongoDB Index Example:</h3><pre><code>// Creating an index\ndb.users.createIndex({ email: 1 });\n\n// Compound index\ndb.users.createIndex({ name: 1, email: 1 });\n\n// Using index in query\ndb.users.find({ email: 'john@example.com' }); // Uses index</code></pre><h3>Types of Indexes:</h3><ul><li><strong>Single-column index:</strong> Index on one column</li><li><strong>Composite index:</strong> Index on multiple columns</li><li><strong>Unique index:</strong> Ensures no duplicate values</li><li><strong>Text index:</strong> For full-text search (MongoDB)</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 73,
    "question": "What are Joins in SQL?",
    "answer": "<p>Joins combine rows from two or more tables based on related columns. Think of it like connecting puzzle pieces from different tables.</p><h3>Types of Joins:</h3><pre><code>-- INNER JOIN: Returns matching records from both tables\nSELECT users.name, orders.order_id\nFROM users\nINNER JOIN orders ON users.id = orders.user_id;\n\n-- LEFT JOIN: Returns all records from left table and matching from right\nSELECT users.name, orders.order_id\nFROM users\nLEFT JOIN orders ON users.id = orders.user_id;\n\n-- RIGHT JOIN: Returns all records from right table and matching from left\nSELECT users.name, orders.order_id\nFROM users\nRIGHT JOIN orders ON users.id = orders.user_id;\n\n-- FULL JOIN: Returns all records when there's a match in either table\nSELECT users.name, orders.order_id\nFROM users\nFULL JOIN orders ON users.id = orders.user_id;</code></pre><h3>Real-world Example:</h3><pre><code>-- Get all users with their orders and products\nSELECT \n  users.name,\n  orders.order_date,\n  products.name as product_name\nFROM users\nINNER JOIN orders ON users.id = orders.user_id\nINNER JOIN order_items ON orders.id = order_items.order_id\nINNER JOIN products ON order_items.product_id = products.id\nWHERE orders.order_date > '2023-01-01';</code></pre>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 74,
    "question": "What is MongoDB Aggregation?",
    "answer": "<p>MongoDB Aggregation is a way to process data records and return computed results. It's like a pipeline where data goes through different stages.</p><h3>Basic Aggregation Example:</h3><pre><code>// Simple aggregation to count documents\ndb.orders.aggregate([\n  { $match: { status: 'completed' } },\n  { $group: { _id: '$customer_id', total: { $sum: '$amount' } } },\n  { $sort: { total: -1 } }\n]);</code></pre><h3>Complex Aggregation Example:</h3><pre><code>// Get total sales by product category with average order value\ndb.orders.aggregate([\n  { $unwind: '$items' },\n  { $lookup: {\n      from: 'products',\n      localField: 'items.product_id',\n      foreignField: '_id',\n      as: 'product'\n    }\n  },\n  { $unwind: '$product' },\n  { $group: {\n      _id: '$product.category',\n      totalSales: { $sum: '$items.price' },\n      avgOrderValue: { $avg: '$items.price' },\n      count: { $sum: 1 }\n    }\n  },\n  { $sort: { totalSales: -1 } }\n]);</code></pre><h3>Common Aggregation Stages:</h3><ul><li><code>$match</code>: Filter documents</li><li><code>$group</code>: Group documents</li><li><code>$sort</code>: Sort documents</li><li><code>$project</code>: Reshape documents</li><li><code>$lookup</code>: Join with another collection</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 75,
    "question": "What is Database Normalization?",
    "answer": "<p>Normalization is the process of organizing data to reduce redundancy and improve data integrity. Think of it like organizing a library - books are categorized, and each book has a unique location.</p><h3>Normal Forms Example:</h3><pre><code>-- Before Normalization\nCREATE TABLE orders (\n  order_id INT,\n  customer_name VARCHAR(100),\n  customer_email VARCHAR(100),\n  product_name VARCHAR(100),\n  product_price DECIMAL,\n  order_date DATE\n);\n\n-- After Normalization (1NF, 2NF, 3NF)\nCREATE TABLE customers (\n  customer_id INT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n\nCREATE TABLE products (\n  product_id INT PRIMARY KEY,\n  name VARCHAR(100),\n  price DECIMAL\n);\n\nCREATE TABLE orders (\n  order_id INT PRIMARY KEY,\n  customer_id INT,\n  order_date DATE,\n  FOREIGN KEY (customer_id) REFERENCES customers(customer_id)\n);\n\nCREATE TABLE order_items (\n  order_id INT,\n  product_id INT,\n  quantity INT,\n  FOREIGN KEY (order_id) REFERENCES orders(order_id),\n  FOREIGN KEY (product_id) REFERENCES products(product_id)\n);</code></pre><h3>Benefits of Normalization:</h3><ul><li>Reduces data redundancy</li><li>Improves data integrity</li><li>Makes updates easier</li><li>Reduces storage space</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 76,
    "question": "What is Database Transactions?",
    "answer": "<p>Transactions are a sequence of operations that are treated as a single unit. They follow the ACID properties: Atomicity, Consistency, Isolation, and Durability.</p><h3>MySQL/PostgreSQL Transaction Example:</h3><pre><code>-- Transfer money between accounts\nBEGIN TRANSACTION;\n\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\n\n-- If everything is okay\nCOMMIT;\n\n-- If there's an error\nROLLBACK;</code></pre><h3>MongoDB Transaction Example:</h3><pre><code>// Transfer money between accounts\nconst session = client.startSession();\n\ntry {\n  session.startTransaction();\n\n  await accounts.updateOne(\n    { _id: 1 },\n    { $inc: { balance: -100 } },\n    { session }\n  );\n\n  await accounts.updateOne(\n    { _id: 2 },\n    { $inc: { balance: 100 } },\n    { session }\n  );\n\n  await session.commitTransaction();\n} catch (error) {\n  await session.abortTransaction();\n  throw error;\n} finally {\n  session.endSession();\n}</code></pre><h3>ACID Properties:</h3><ul><li><strong>Atomicity:</strong> All operations succeed or all fail</li><li><strong>Consistency:</strong> Database remains in a valid state</li><li><strong>Isolation:</strong> Transactions don't interfere with each other</li><li><strong>Durability:</strong> Committed changes are permanent</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 77,
    "question": "What is Database Backup and Recovery?",
    "answer": "<p>Backup and recovery are processes to protect and restore database data. Think of it like having a spare key for your house.</p><h3>MySQL Backup Example:</h3><pre><code>-- Full backup\nmysqldump -u root -p database_name > backup.sql\n\n-- Restore from backup\nmysql -u root -p database_name < backup.sql\n\n-- Automated backup script\n#!/bin/bash\nmysqldump -u root -p database_name > backup_$(date +%Y%m%d).sql</code></pre><h3>MongoDB Backup Example:</h3><pre><code>// Full backup\nmongodump --db database_name --out /backup\n\n// Restore from backup\nmongorestore --db database_name /backup/database_name\n\n// Automated backup script\n#!/bin/bash\nmongodump --db database_name --out /backup/$(date +%Y%m%d)</code></pre><h3>Types of Backups:</h3><ul><li><strong>Full backup:</strong> Complete database copy</li><li><strong>Incremental backup:</strong> Only changed data since last backup</li><li><strong>Point-in-time recovery:</strong> Restore to specific time</li><li><strong>Continuous backup:</strong> Real-time data protection</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 78,
    "question": "What is Database Query Optimization?",
    "answer": "<p>Query optimization is the process of improving database query performance. Think of it like finding the fastest route to your destination.</p><h3>MySQL/PostgreSQL Optimization Examples:</h3><pre><code>-- Bad query (no index usage)\nSELECT * FROM users WHERE name LIKE '%John%';\n\n-- Optimized query (using index)\nSELECT id, name FROM users WHERE name LIKE 'John%';\n\n-- Using EXPLAIN to analyze query\nEXPLAIN SELECT * FROM orders \nWHERE user_id = 1 \nAND order_date > '2023-01-01';\n\n-- Optimizing JOIN queries\nSELECT u.name, o.order_id\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nWHERE o.status = 'completed'\nLIMIT 10;</code></pre><h3>MongoDB Optimization Examples:</h3><pre><code>// Bad query (no index)\ndb.users.find({ name: { $regex: /John/ } });\n\n// Optimized query (using index)\ndb.users.find({ name: { $regex: /^John/ } });\n\n// Using explain() to analyze query\ndb.orders.find({\n  user_id: 1,\n  order_date: { $gt: new Date('2023-01-01') }\n}).explain('executionStats');\n\n// Optimizing aggregation pipeline\ndb.orders.aggregate([\n  { $match: { status: 'completed' } },\n  { $limit: 10 },\n  { $lookup: {\n      from: 'users',\n      localField: 'user_id',\n      foreignField: '_id',\n      as: 'user'\n    }\n  }\n]);</code></pre><h3>Optimization Techniques:</h3><ul><li>Use appropriate indexes</li><li>Limit the data returned</li><li>Avoid SELECT *</li><li>Use proper JOIN types</li><li>Optimize WHERE clauses</li><li>Use pagination</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 79,
    "question": "What is Database Replication and Sharding?",
    "answer": "<p>Replication and sharding are techniques for scaling databases. Replication is like having multiple copies of your data, while sharding is like splitting your data into smaller pieces.</p><h3>MySQL Replication Example:</h3><pre><code>-- Master configuration (my.cnf)\n[mysqld]\nserver-id = 1\nlog-bin = mysql-bin\n\n-- Slave configuration\n[mysqld]\nserver-id = 2\nrelay-log = mysql-relay-bin\nread_only = 1\n\n-- Setting up replication\nCHANGE MASTER TO\n  MASTER_HOST='master_host',\n  MASTER_USER='repl_user',\n  MASTER_PASSWORD='password',\n  MASTER_LOG_FILE='mysql-bin.000001',\n  MASTER_LOG_POS=0;\n\nSTART SLAVE;</code></pre><h3>MongoDB Sharding Example:</h3><pre><code>// Enable sharding for database\nsh.enableSharding('mydb');\n\n// Shard a collection\nsh.shardCollection('mydb.users', { country: 1, _id: 1 });\n\n// Add shards\nsh.addShard('shard1:27017');\nsh.addShard('shard2:27017');\n\n// Check shard status\nsh.status();</code></pre><h3>Benefits:</h3><ul><li><strong>Replication:</strong><ul><li>High availability</li><li>Read scaling</li><li>Disaster recovery</li></ul></li><li><strong>Sharding:</strong><ul><li>Write scaling</li><li>Data distribution</li><li>Improved performance</li></ul></li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 80,
    "question": "What are Stored Procedures and Functions?",
    "answer": "<p>Stored procedures and functions are pre-compiled SQL statements stored in the database. Think of them like pre-written recipes that you can use anytime.</p><h3>MySQL Stored Procedure Example:</h3><pre><code>DELIMITER //\n\nCREATE PROCEDURE GetUserOrders(IN user_id INT)\nBEGIN\n  SELECT o.order_id, o.order_date, p.name as product_name\n  FROM orders o\n  JOIN order_items oi ON o.id = oi.order_id\n  JOIN products p ON oi.product_id = p.id\n  WHERE o.user_id = user_id;\nEND //\n\nDELIMITER ;\n\n-- Using the stored procedure\nCALL GetUserOrders(1);</code></pre><h3>PostgreSQL Function Example:</h3><pre><code>CREATE OR REPLACE FUNCTION calculate_order_total(order_id INT)\nRETURNS DECIMAL AS $$\nDECLARE\n  total DECIMAL;\nBEGIN\n  SELECT SUM(quantity * price) INTO total\n  FROM order_items oi\n  JOIN products p ON oi.product_id = p.id\n  WHERE oi.order_id = $1;\n  \n  RETURN total;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Using the function\nSELECT calculate_order_total(1);</code></pre><h3>Benefits:</h3><ul><li>Improved performance</li><li>Code reusability</li><li>Better security</li><li>Reduced network traffic</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 81,
    "question": "What is Database Security?",
    "answer": "<p>Database security involves protecting data from unauthorized access and ensuring data integrity. Think of it like securing your house with locks and alarms.</p><h3>MySQL Security Example:</h3><pre><code>-- Create user with specific privileges\nCREATE USER 'app_user'@'localhost' IDENTIFIED BY 'password';\nGRANT SELECT, INSERT, UPDATE ON mydb.* TO 'app_user'@'localhost';\n\n-- Restrict access to specific columns\nGRANT SELECT (id, name, email) ON mydb.users TO 'read_user'@'localhost';\n\n-- Enable SSL connection\nALTER USER 'app_user'@'localhost' REQUIRE SSL;</code></pre><h3>MongoDB Security Example:</h3><pre><code>// Create user with specific roles\ndb.createUser({\n  user: 'app_user',\n  pwd: 'password',\n  roles: [\n    { role: 'readWrite', db: 'mydb' },\n    { role: 'read', db: 'reports' }\n  ]\n});\n\n// Enable authentication\nsecurity:\n  authorization: enabled\n\n// Enable SSL\nnet:\n  ssl:\n    mode: requireSSL\n    PEMKeyFile: /path/to/mongodb.pem</code></pre><h3>Security Best Practices:</h3><ul><li>Use strong passwords</li><li>Implement least privilege</li><li>Enable encryption</li><li>Regular security audits</li><li>Keep software updated</li><li>Backup regularly</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 82,
    "question": "What is Database Migration?",
    "answer": "<p>Database migration is the process of moving data from one database to another or updating database schema. Think of it like moving to a new house with all your belongings.</p><h3>MySQL Migration Example:</h3><pre><code>-- Create migration table\nCREATE TABLE migrations (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  name VARCHAR(255),\n  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Migration file: 001_create_users_table.sql\nCREATE TABLE users (\n  id INT PRIMARY KEY,\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n\n-- Migration file: 002_add_phone_to_users.sql\nALTER TABLE users\nADD COLUMN phone VARCHAR(20);\n\n-- Rollback file: 002_add_phone_to_users_rollback.sql\nALTER TABLE users\nDROP COLUMN phone;</code></pre><h3>MongoDB Migration Example:</h3><pre><code>// Migration script\nasync function migrateData() {\n  // Update document structure\n  await db.users.updateMany(\n    { phone: { $exists: false } },\n    { $set: { phone: null } }\n  );\n\n  // Move data to new collection\n  await db.users.aggregate([\n    { $match: { status: 'active' } },\n    { $out: 'active_users' }\n  ]);\n\n  // Create new indexes\n  await db.active_users.createIndex({ email: 1 });\n}</code></pre><h3>Migration Best Practices:</h3><ul><li>Backup before migration</li><li>Test in staging environment</li><li>Plan for rollback</li><li>Schedule during low traffic</li><li>Monitor progress</li><li>Verify data integrity</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 83,
    "question": "What is Database Monitoring?",
    "answer": "<p>Database monitoring involves tracking database performance, health, and usage. Think of it like having a dashboard for your car showing speed, fuel, and engine status.</p><h3>MySQL Monitoring Example:</h3><pre><code>-- Check server status\nSHOW STATUS;\n\n-- Monitor slow queries\nSHOW VARIABLES LIKE 'slow_query%';\nSHOW VARIABLES LIKE 'long_query_time';\n\n-- Check process list\nSHOW PROCESSLIST;\n\n-- Monitor table statistics\nSHOW TABLE STATUS;\n\n-- Check index usage\nSHOW INDEX FROM users;</code></pre><h3>MongoDB Monitoring Example:</h3><pre><code>// Check server status\ndb.serverStatus();\n\n// Monitor operations\ndb.currentOp();\n\n// Check collection stats\ndb.users.stats();\n\n// Monitor index usage\ndb.users.aggregate([\n  { $indexStats: {} }\n]);\n\n// Check replication status\nrs.status();</code></pre><h3>Key Metrics to Monitor:</h3><ul><li>Query performance</li><li>Connection count</li><li>Memory usage</li><li>Disk space</li><li>Replication lag</li><li>Error rates</li><li>Backup status</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 84,
    "question": "How to find the second highest/lowest value in a table?",
    "answer": "<p>There are several ways to find the second highest or lowest value in a table. Here are different approaches:</p><h3>Using LIMIT and OFFSET:</h3><pre><code>-- Second highest salary\nSELECT salary\nFROM employees\nORDER BY salary DESC\nLIMIT 1 OFFSET 1;\n\n-- Second lowest salary\nSELECT salary\nFROM employees\nORDER BY salary ASC\nLIMIT 1 OFFSET 1;</code></pre><h3>Using Subquery:</h3><pre><code>-- Second highest salary\nSELECT MAX(salary)\nFROM employees\nWHERE salary < (\n    SELECT MAX(salary)\n    FROM employees\n);\n\n-- Second lowest salary\nSELECT MIN(salary)\nFROM employees\nWHERE salary > (\n    SELECT MIN(salary)\n    FROM employees\n);</code></pre><h3>Using DENSE_RANK() (Modern SQL):</h3><pre><code>-- Second highest salary\nSELECT salary\nFROM (\n    SELECT salary,\n           DENSE_RANK() OVER (ORDER BY salary DESC) as rank\n    FROM employees\n) ranked\nWHERE rank = 2;\n\n-- Second lowest salary\nSELECT salary\nFROM (\n    SELECT salary,\n           DENSE_RANK() OVER (ORDER BY salary ASC) as rank\n    FROM employees\n) ranked\nWHERE rank = 2;</code></pre><h3>Handling Edge Cases:</h3><pre><code>-- Handle ties and NULL values\nSELECT salary\nFROM (\n    SELECT DISTINCT salary,\n           DENSE_RANK() OVER (ORDER BY salary DESC NULLS LAST) as rank\n    FROM employees\n) ranked\nWHERE rank = 2;</code></pre>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 85,
    "question": "How to find duplicate records in a table?",
    "answer": "<p>Finding duplicate records is a common task in database management. Here are different approaches:</p><h3>Using GROUP BY and HAVING:</h3><pre><code>-- Find duplicate emails\nSELECT email, COUNT(*) as count\nFROM users\nGROUP BY email\nHAVING COUNT(*) > 1;\n\n-- Find duplicate combinations\nSELECT first_name, last_name, COUNT(*) as count\nFROM employees\nGROUP BY first_name, last_name\nHAVING COUNT(*) > 1;</code></pre><h3>Using Window Functions:</h3><pre><code>-- Find all duplicate records with their IDs\nSELECT *\nFROM (\n    SELECT *,\n           COUNT(*) OVER (PARTITION BY email) as email_count\n    FROM users\n) counted\nWHERE email_count > 1;</code></pre><h3>Using Self Join:</h3><pre><code>-- Find duplicate records using self join\nSELECT DISTINCT a.*\nFROM users a\nJOIN users b\n    ON a.email = b.email\n    AND a.id < b.id;</code></pre><h3>Removing Duplicates:</h3><pre><code>-- Keep one record and delete others\nDELETE FROM users a\nUSING users b\nWHERE a.email = b.email\nAND a.id > b.id;</code></pre>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 86,
    "question": "How to find records that exist in one table but not in another?",
    "answer": "<p>There are several ways to find records that exist in one table but not in another. Here are the common approaches:</p><h3>Using NOT EXISTS:</h3><pre><code>-- Find customers who haven't placed orders\nSELECT c.*\nFROM customers c\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM orders o\n    WHERE o.customer_id = c.id\n);</code></pre><h3>Using LEFT JOIN:</h3><pre><code>-- Find customers who haven't placed orders\nSELECT c.*\nFROM customers c\nLEFT JOIN orders o ON c.id = o.customer_id\nWHERE o.id IS NULL;</code></pre><h3>Using NOT IN:</h3><pre><code>-- Find customers who haven't placed orders\nSELECT c.*\nFROM customers c\nWHERE c.id NOT IN (\n    SELECT customer_id\n    FROM orders\n);</code></pre><h3>Using EXCEPT (PostgreSQL):</h3><pre><code>-- Find customers who haven't placed orders\nSELECT id FROM customers\nEXCEPT\nSELECT customer_id FROM orders;</code></pre><h3>Performance Considerations:</h3><ul><li>NOT EXISTS is generally more efficient than NOT IN</li><li>LEFT JOIN can be faster with proper indexes</li><li>EXCEPT is clean but may be slower for large datasets</li><li>Consider using appropriate indexes on join columns</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 87,
    "question": "How to find the top N records in each group?",
    "answer": "<p>Finding the top N records in each group is a common requirement. Here are different approaches:</p><h3>Using ROW_NUMBER():</h3><pre><code>-- Top 3 highest paid employees in each department\nSELECT *\nFROM (\n    SELECT *,\n           ROW_NUMBER() OVER (\n               PARTITION BY department_id\n               ORDER BY salary DESC\n           ) as rank\n    FROM employees\n) ranked\nWHERE rank <= 3;</code></pre><h3>Using DENSE_RANK():</h3><pre><code>-- Top 3 highest paid employees (including ties)\nSELECT *\nFROM (\n    SELECT *,\n           DENSE_RANK() OVER (\n               PARTITION BY department_id\n               ORDER BY salary DESC\n           ) as rank\n    FROM employees\n) ranked\nWHERE rank <= 3;</code></pre><h3>Using Correlated Subquery:</h3><pre><code>-- Top 3 highest paid employees in each department\nSELECT e.*\nFROM employees e\nWHERE (\n    SELECT COUNT(*)\n    FROM employees e2\n    WHERE e2.department_id = e.department_id\n    AND e2.salary > e.salary\n) < 3;</code></pre><h3>Using LIMIT with LATERAL (PostgreSQL):</h3><pre><code>-- Top 3 highest paid employees in each department\nSELECT d.name as department, e.*\nFROM departments d\nCROSS JOIN LATERAL (\n    SELECT *\n    FROM employees\n    WHERE department_id = d.id\n    ORDER BY salary DESC\n    LIMIT 3\n) e;</code></pre>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 88,
    "question": "How to find records with the most recent date in each group?",
    "answer": "<p>Finding the most recent records in each group is a common requirement. Here are different approaches:</p><h3>Using Window Functions:</h3><pre><code>-- Most recent order for each customer\nSELECT *\nFROM (\n    SELECT *,\n           ROW_NUMBER() OVER (\n               PARTITION BY customer_id\n               ORDER BY order_date DESC\n           ) as rn\n    FROM orders\n) ranked\nWHERE rn = 1;</code></pre><h3>Using Correlated Subquery:</h3><pre><code>-- Most recent order for each customer\nSELECT o.*\nFROM orders o\nWHERE o.order_date = (\n    SELECT MAX(order_date)\n    FROM orders o2\n    WHERE o2.customer_id = o.customer_id\n);</code></pre><h3>Using JOIN:</h3><pre><code>-- Most recent order for each customer\nSELECT o.*\nFROM orders o\nJOIN (\n    SELECT customer_id, MAX(order_date) as max_date\n    FROM orders\n    GROUP BY customer_id\n) latest ON o.customer_id = latest.customer_id\n    AND o.order_date = latest.max_date;</code></pre><h3>Using DISTINCT ON (PostgreSQL):</h3><pre><code>-- Most recent order for each customer\nSELECT DISTINCT ON (customer_id) *\nFROM orders\nORDER BY customer_id, order_date DESC;</code></pre>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 89,
    "question": "What is the difference between WHERE and HAVING clauses in SQL?",
    "answer": "<p>The main difference between WHERE and HAVING is that WHERE filters individual rows before grouping, while HAVING filters groups after grouping. Think of WHERE as a filter for individual items, and HAVING as a filter for groups of items.</p><h3>Basic Example:</h3><pre><code>-- Using WHERE (filters individual rows)\nSELECT department, AVG(salary) as avg_salary\nFROM employees\nWHERE salary > 30000  -- Filters individual employees\nGROUP BY department;\n\n-- Using HAVING (filters groups)\nSELECT department, AVG(salary) as avg_salary\nFROM employees\nGROUP BY department\nHAVING AVG(salary) > 50000;  -- Filters departments</code></pre><h3>Real-world Example:</h3><pre><code>-- Find departments with more than 5 employees\n-- who earn more than 30000\nSELECT \n    department,\n    COUNT(*) as employee_count,\n    AVG(salary) as avg_salary\nFROM employees\nWHERE salary > 30000  -- First filter individual employees\nGROUP BY department\nHAVING COUNT(*) > 5;  -- Then filter departments</code></pre><h3>Key Differences:</h3><ul><li><strong>WHERE:</strong><ul><li>Filters individual rows</li><li>Used before GROUP BY</li><li>Can't use aggregate functions</li><li>Faster performance</li></ul></li><li><strong>HAVING:</strong><ul><li>Filters groups</li><li>Used after GROUP BY</li><li>Can use aggregate functions</li><li>Slower performance</li></ul></li></ul><h3>Common Use Cases:</h3><pre><code>-- Find departments with high average salary\nSELECT department, AVG(salary) as avg_salary\nFROM employees\nGROUP BY department\nHAVING AVG(salary) > 50000;\n\n-- Find customers with multiple orders\nSELECT customer_id, COUNT(*) as order_count\nFROM orders\nGROUP BY customer_id\nHAVING COUNT(*) > 3;\n\n-- Find products with total sales over 1000\nSELECT product_id, SUM(quantity * price) as total_sales\nFROM order_items\nGROUP BY product_id\nHAVING SUM(quantity * price) > 1000;</code></pre><h3>Best Practices:</h3><ul><li>Use WHERE for filtering individual rows</li><li>Use HAVING for filtering groups</li><li>Apply WHERE first to reduce data before grouping</li><li>Use HAVING only when you need to filter on aggregate results</li><li>Consider performance impact when using HAVING</li></ul>",
    "category": "Database",
    "difficulty": "Beginner"
  },
  {
    "id": 90,
    "question": "What are the most commonly used Array.prototype methods in JavaScript?",
    "answer": "<p>Array.prototype methods are built-in functions that help you work with arrays. Here are the most commonly used ones with simple examples:</p><h3>1. map() - Transform each element</h3><pre><code>// Double each number in array\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n\n// Convert names to uppercase\nconst names = ['john', 'jane', 'bob'];\nconst upperNames = names.map(name => name.toUpperCase());\nconsole.log(upperNames); // ['JOHN', 'JANE', 'BOB']</code></pre><h3>2. filter() - Select elements that match a condition</h3><pre><code>// Get even numbers\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\nconsole.log(evenNumbers); // [2, 4, 6]\n\n// Get active users\nconst users = [\n  { name: 'John', active: true },\n  { name: 'Jane', active: false },\n  { name: 'Bob', active: true }\n];\nconst activeUsers = users.filter(user => user.active);\nconsole.log(activeUsers); // [{ name: 'John', active: true }, { name: 'Bob', active: true }]</code></pre><h3>3. find() - Find first matching element</h3><pre><code>// Find first number greater than 3\nconst numbers = [1, 2, 3, 4, 5];\nconst found = numbers.find(num => num > 3);\nconsole.log(found); // 4\n\n// Find user by name\nconst users = [\n  { id: 1, name: 'John' },\n  { id: 2, name: 'Jane' },\n  { id: 3, name: 'Bob' }\n];\nconst user = users.find(user => user.name === 'Jane');\nconsole.log(user); // { id: 2, name: 'Jane' }</code></pre><h3>4. reduce() - Combine elements into a single value</h3><pre><code>// Sum all numbers\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((total, num) => total + num, 0);\nconsole.log(sum); // 15\n\n// Create object from array\nconst fruits = ['apple', 'banana', 'apple', 'orange'];\nconst count = fruits.reduce((acc, fruit) => {\n  acc[fruit] = (acc[fruit] || 0) + 1;\n  return acc;\n}, {});\nconsole.log(count); // { apple: 2, banana: 1, orange: 1 }</code></pre><h3>5. some() and every() - Check conditions</h3><pre><code>// Check if any number is even\nconst numbers = [1, 2, 3, 4, 5];\nconst hasEven = numbers.some(num => num % 2 === 0);\nconsole.log(hasEven); // true\n\n// Check if all numbers are positive\nconst allPositive = numbers.every(num => num > 0);\nconsole.log(allPositive); // true</code></pre><h3>6. forEach() - Execute function for each element</h3><pre><code>// Print each name\nconst names = ['John', 'Jane', 'Bob'];\nnames.forEach(name => console.log(`Hello, ${name}!`));\n// Output:\n// Hello, John!\n// Hello, Jane!\n// Hello, Bob!</code></pre><h3>7. includes() - Check if array contains value</h3><pre><code>// Check if array contains value\nconst fruits = ['apple', 'banana', 'orange'];\nconsole.log(fruits.includes('banana')); // true\nconsole.log(fruits.includes('grape')); // false</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 91,
    "question": "What are the most commonly used String.prototype methods in JavaScript?",
    "answer": "<p>String.prototype methods are built-in functions that help you work with strings. Here are the most commonly used ones with simple examples:</p><h3>1. toUpperCase() and toLowerCase() - Change case</h3><pre><code>const name = 'John Doe';\nconsole.log(name.toUpperCase()); // 'JOHN DOE'\nconsole.log(name.toLowerCase()); // 'john doe'</code></pre><h3>2. trim() - Remove whitespace</h3><pre><code>const text = '  Hello World  ';\nconsole.log(text.trim()); // 'Hello World'\nconsole.log(text.trimStart()); // 'Hello World  '\nconsole.log(text.trimEnd()); // '  Hello World'</code></pre><h3>3. split() - Split string into array</h3><pre><code>// Split by space\nconst sentence = 'Hello World';\nconst words = sentence.split(' ');\nconsole.log(words); // ['Hello', 'World']\n\n// Split by comma\nconst csv = 'John,Doe,30';\nconst data = csv.split(',');\nconsole.log(data); // ['John', 'Doe', '30']</code></pre><h3>4. replace() and replaceAll() - Replace text</h3><pre><code>// Replace first occurrence\nconst text = 'Hello World';\nconsole.log(text.replace('World', 'JavaScript')); // 'Hello JavaScript'\n\n// Replace all occurrences\nconst text = 'Hello World World';\nconsole.log(text.replaceAll('World', 'JavaScript')); // 'Hello JavaScript JavaScript'</code></pre><h3>5. includes() - Check if string contains text</h3><pre><code>const text = 'Hello World';\nconsole.log(text.includes('World')); // true\nconsole.log(text.includes('JavaScript')); // false</code></pre><h3>6. startsWith() and endsWith() - Check beginning/end</h3><pre><code>const filename = 'document.pdf';\nconsole.log(filename.endsWith('.pdf')); // true\nconsole.log(filename.startsWith('doc')); // true</code></pre><h3>7. slice() - Extract part of string</h3><pre><code>const text = 'Hello World';\nconsole.log(text.slice(0, 5)); // 'Hello'\nconsole.log(text.slice(6)); // 'World'\nconsole.log(text.slice(-5)); // 'World'</code></pre><h3>8. padStart() and padEnd() - Add padding</h3><pre><code>// Pad with zeros\nconst number = '5';\nconsole.log(number.padStart(3, '0')); // '005'\n\n// Pad with spaces\nconst name = 'John';\nconsole.log(name.padEnd(10, ' ')); // 'John      '</code></pre><h3>9. repeat() - Repeat string</h3><pre><code>const text = 'Ha';\nconsole.log(text.repeat(3)); // 'HaHaHa'</code></pre><h3>10. indexOf() and lastIndexOf() - Find position</h3><pre><code>const text = 'Hello World World';\nconsole.log(text.indexOf('World')); // 6\nconsole.log(text.lastIndexOf('World')); // 12</code></pre><h3>Real-world Examples:</h3><pre><code>// Format phone number\nfunction formatPhoneNumber(number) {\n  return number\n    .replace(/(\\d{3})(\\d{3})(\\d{4})/, '($1) $2-$3');\n}\nconsole.log(formatPhoneNumber('1234567890')); // '(123) 456-7890'\n\n// Validate email\nfunction isValidEmail(email) {\n  return email.includes('@') && email.includes('.');\n}\nconsole.log(isValidEmail('john@example.com')); // true\n\n// Capitalize first letter\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconsole.log(capitalize('hello')); // 'Hello'</code></pre>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  },
  {
    "id": 92,
    "question": "What is TypeScript and what are its main features?",
    "answer": "<p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It adds static typing to JavaScript, making it more robust and maintainable.</p><h3>Main Features:</h3><ul><li>Static typing</li><li>Object-oriented programming</li><li>Type inference</li><li>Interfaces</li><li>Generics</li></ul><h3>Example:</h3><pre><code>// JavaScript\nfunction add(a, b) {\n  return a + b;\n}\n\n// TypeScript\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Using the function\nconsole.log(add(5, 3)); // 8\nconsole.log(add('5', '3')); // Error: Argument of type 'string' is not assignable to parameter of type 'number'</code></pre>",
    "category": "TypeScript",
    "difficulty": "Beginner"
  },
  {
    "id": 93,
    "question": "What are TypeScript Interfaces and how do they work?",
    "answer": "<p>Interfaces in TypeScript define the structure of an object. They act like contracts that objects must follow.</p><h3>Basic Interface Example:</h3><pre><code>// Define interface\ninterface User {\n  name: string;\n  age: number;\n  email?: string; // Optional property\n}\n\n// Use interface\nconst user: User = {\n  name: 'John',\n  age: 30\n  // email is optional, so we can omit it\n};\n\n// Function using interface\nfunction printUser(user: User): void {\n  console.log(`${user.name} is ${user.age} years old`);\n}</code></pre><h3>Extending Interfaces:</h3><pre><code>interface Employee extends User {\n  department: string;\n  salary: number;\n}\n\nconst employee: Employee = {\n  name: 'Jane',\n  age: 25,\n  department: 'IT',\n  salary: 50000\n};</code></pre>",
    "category": "TypeScript",
    "difficulty": "Beginner"
  },
  {
    "id": 94,
    "question": "What are TypeScript Generics and when should you use them?",
    "answer": "<p>Generics allow you to write flexible, reusable code that can work with different types. They're like templates for types.</p><h3>Basic Generic Example:</h3><pre><code>// Generic function\nfunction getFirst<T>(arr: T[]): T {\n  return arr[0];\n}\n\n// Using the generic function\nconst numbers = getFirst<number>([1, 2, 3]); // number\nconst strings = getFirst<string>(['a', 'b', 'c']); // string</code></pre><h3>Generic Interface Example:</h3><pre><code>interface Box<T> {\n  value: T;\n}\n\nconst numberBox: Box<number> = { value: 42 };\nconst stringBox: Box<string> = { value: 'Hello' };</code></pre><h3>Generic Class Example:</h3><pre><code>class Container<T> {\n  private items: T[] = [];\n\n  add(item: T): void {\n    this.items.push(item);\n  }\n\n  getFirst(): T {\n    return this.items[0];\n  }\n}\n\n// Using the generic class\nconst numberContainer = new Container<number>();\nnumberContainer.add(1);\nnumberContainer.add(2);\nconsole.log(numberContainer.getFirst()); // 1</code></pre>",
    "category": "TypeScript",
    "difficulty": "Intermediate"
  },
  {
    "id": 95,
    "question": "What is Type Inference in TypeScript?",
    "answer": "<p>Type inference is TypeScript's ability to automatically determine the type of a variable based on its value. It helps reduce the need for explicit type annotations.</p><h3>Basic Examples:</h3><pre><code>// Type inference with variables\nlet name = 'John'; // TypeScript infers type as string\nlet age = 30; // TypeScript infers type as number\nlet isActive = true; // TypeScript infers type as boolean\n\n// Type inference with arrays\nconst numbers = [1, 2, 3]; // TypeScript infers type as number[]\nconst mixed = [1, 'two', 3]; // TypeScript infers type as (number | string)[]\n\n// Type inference with objects\nconst user = {\n  name: 'John',\n  age: 30\n}; // TypeScript infers type as { name: string; age: number }</code></pre><h3>Function Return Type Inference:</h3><pre><code>// TypeScript infers return type as number\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\n// TypeScript infers return type as string\nfunction greet(name: string) {\n  return `Hello, ${name}!`;\n}</code></pre>",
    "category": "TypeScript",
    "difficulty": "Beginner"
  },
  {
    "id": 96,
    "question": "What are Type Guards in TypeScript?",
    "answer": "<p>Type guards are expressions that perform runtime checks to ensure a value is of a specific type. They help narrow down types within conditional blocks.</p><h3>Basic Type Guard Examples:</h3><pre><code>// typeof type guard\nfunction processValue(value: string | number) {\n  if (typeof value === 'string') {\n    // TypeScript knows value is string here\n    console.log(value.toUpperCase());\n  } else {\n    // TypeScript knows value is number here\n    console.log(value.toFixed(2));\n  }\n}\n\n// instanceof type guard\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    return 'Woof!';\n  }\n}\n\nfunction processAnimal(animal: Animal) {\n  if (animal instanceof Dog) {\n    // TypeScript knows animal is Dog here\n    console.log(animal.bark());\n  }\n}</code></pre><h3>Custom Type Guard Example:</h3><pre><code>interface Bird {\n  fly(): void;\n  layEggs(): void;\n}\n\ninterface Fish {\n  swim(): void;\n  layEggs(): void;\n}\n\n// Custom type guard\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n\nfunction move(pet: Fish | Bird) {\n  if (isFish(pet)) {\n    // TypeScript knows pet is Fish here\n    pet.swim();\n  } else {\n    // TypeScript knows pet is Bird here\n    pet.fly();\n  }\n}</code></pre>",
    "category": "TypeScript",
    "difficulty": "Intermediate"
  },
  {
    "id": 97,
    "question": "What are TypeScript Decorators and how do they work?",
    "answer": "<p>Decorators are a design pattern that allows you to add behavior to classes and their members. They are functions that can be attached to classes, methods, or properties.</p><h3>Basic Decorator Examples:</h3><pre><code>// Class decorator\nfunction log(target: any) {\n  console.log('Class decorator called');\n}\n\n@log\nclass Example {\n  // Class implementation\n}\n\n// Method decorator\nfunction logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${propertyKey} with:`, args);\n    return originalMethod.apply(this, args);\n  };\n\n  return descriptor;\n}\n\nclass Calculator {\n  @logMethod\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}</code></pre><h3>Property Decorator Example:</h3><pre><code>function required(target: any, propertyKey: string) {\n  let value: string;\n\n  const getter = function() {\n    return value;\n  };\n\n  const setter = function(newVal: string) {\n    if (!newVal) {\n      throw new Error(`${propertyKey} is required`);\n    }\n    value = newVal;\n  };\n\n  Object.defineProperty(target, propertyKey, {\n    get: getter,\n    set: setter\n  });\n}\n\nclass User {\n  @required\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}</code></pre>",
    "category": "TypeScript",
    "difficulty": "Advanced"
  },
  {
    "id": 98,
    "question": "What are TypeScript Utility Types?",
    "answer": "<p>Utility types are built-in TypeScript types that help transform existing types. They make it easier to work with types in a flexible way.</p><h3>Common Utility Types:</h3><pre><code>// Partial<T> - Makes all properties optional\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype PartialUser = Partial<User>;\n// Equivalent to:\n// { name?: string; age?: number; }\n\n// Required<T> - Makes all properties required\ninterface Config {\n  name?: string;\n  age?: number;\n}\n\ntype RequiredConfig = Required<Config>;\n// Equivalent to:\n// { name: string; age: number; }\n\n// Pick<T, K> - Select specific properties\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, 'title' | 'completed'>;\n// Equivalent to:\n// { title: string; completed: boolean; }\n\n// Omit<T, K> - Remove specific properties\ntype TodoInfo = Omit<Todo, 'completed'>;\n// Equivalent to:\n// { title: string; description: string; }</code></pre><h3>More Utility Types:</h3><pre><code>// Record<K, T> - Create type with specific keys and values\ntype CatInfo = {\n  age: number;\n  breed: string;\n};\n\ntype CatName = 'miffy' | 'boris';\nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: 'Persian' },\n  boris: { age: 5, breed: 'Maine Coon' }\n};\n\n// ReturnType<T> - Get return type of function\ntype T0 = ReturnType<() => string>; // string\ntype T1 = ReturnType<(s: string) => void>; // void\n\n// Parameters<T> - Get parameters of function\ntype T2 = Parameters<(name: string, age: number) => void>; // [string, number]</code></pre>",
    "category": "TypeScript",
    "difficulty": "Intermediate"
  },
  {
    "id": 99,
    "question": "What is the difference between 'type' and 'interface' in TypeScript?",
    "answer": "<p>Both 'type' and 'interface' are used to define custom types in TypeScript, but they have some key differences.</p><h3>Basic Examples:</h3><pre><code>// Interface\ninterface User {\n  name: string;\n  age: number;\n}\n\n// Type\ntype User = {\n  name: string;\n  age: number;\n};\n\n// Both can be extended\ninterface Employee extends User {\n  department: string;\n}\n\ntype Employee = User & {\n  department: string;\n};</code></pre><h3>Key Differences:</h3><ul><li><strong>Declaration Merging:</strong><ul><li>Interfaces can be merged</li><li>Types cannot be merged</li></ul></li><li><strong>Computed Properties:</strong><ul><li>Types can use computed properties</li><li>Interfaces cannot</li></ul></li><li><strong>Union Types:</strong><ul><li>Types can create union types</li><li>Interfaces cannot</li></ul></li></ul><h3>Examples of Differences:</h3><pre><code>// Interface merging\ninterface Animal {\n  name: string;\n}\ninterface Animal {\n  age: number;\n}\n// Result: { name: string; age: number; }\n\n// Type union\ntype Status = 'pending' | 'approved' | 'rejected';\n\n// Computed properties in type\ntype Keys = 'firstname' | 'surname';\ntype DudeType = {\n  [key in Keys]: string;\n};\n// Result: { firstname: string; surname: string; }</code></pre><h3>When to Use Each:</h3><ul><li><strong>Use Interface when:</strong><ul><li>Defining object shapes</li><li>Need declaration merging</li><li>Working with object-oriented design</li></ul></li><li><strong>Use Type when:</strong><ul><li>Creating union types</li><li>Working with tuples</li><li>Need computed properties</li><li>Creating mapped types</li></ul></li></ul>",
    "category": "TypeScript",
    "difficulty": "Intermediate"
  },
  {
    "id": 100,
    "question": "What are TypeScript Enums and when should you use them?",
    "answer": "<p>Enums in TypeScript are a way to define a set of named constants. They make it easier to work with a set of related values.</p><h3>Basic Enum Examples:</h3><pre><code>// Numeric enum\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n\n// String enum\nenum UserRole {\n  Admin = 'ADMIN',\n  User = 'USER',\n  Guest = 'GUEST'\n}\n\n// Using enums\nfunction move(direction: Direction) {\n  switch (direction) {\n    case Direction.Up:\n      console.log('Moving up');\n      break;\n    case Direction.Down:\n      console.log('Moving down');\n      break;\n    // ...\n  }\n}</code></pre><h3>Const Enums:</h3><pre><code>// Const enum (more efficient)\nconst enum Colors {\n  Red,\n  Green,\n  Blue\n}\n\n// Using const enum\nlet color = Colors.Red;\n// Compiles to: let color = 0;</code></pre><h3>Real-world Example:</h3><pre><code>// HTTP Status Codes\nenum HttpStatus {\n  OK = 200,\n  BadRequest = 400,\n  Unauthorized = 401,\n  Forbidden = 403,\n  NotFound = 404,\n  InternalServerError = 500\n}\n\nfunction handleResponse(status: HttpStatus) {\n  switch (status) {\n    case HttpStatus.OK:\n      return 'Success';\n    case HttpStatus.NotFound:\n      return 'Resource not found';\n    case HttpStatus.InternalServerError:\n      return 'Server error';\n    default:\n      return 'Unknown status';\n  }\n}</code></pre><h3>When to Use Enums:</h3><ul><li>When you have a set of related constants</li><li>When you need type safety for a set of values</li><li>When you want to provide better code documentation</li><li>When you need to iterate over a set of values</li></ul>",
    "category": "TypeScript",
    "difficulty": "Beginner"
  },
  {
    "id": 101,
    "question": "What is Dependency Injection (DI) in Angular and how does it work?",
    "answer": "<p>Dependency Injection is a design pattern where a class receives its dependencies from external sources rather than creating them itself. Angular has a built-in DI system.</p><h3>Basic Example:</h3><pre><code>// Service\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor() {}\n  getUsers() {\n    return ['John', 'Jane'];\n  }\n}\n\n// Component using the service\n@Component({\n  selector: 'app-users',\n  template: '...'\n})\nexport class UsersComponent {\n  constructor(private userService: UserService) {}\n  \n  ngOnInit() {\n    const users = this.userService.getUsers();\n  }\n}</code></pre><h3>Different Ways to Provide Services:</h3><pre><code>// 1. Root level (singleton)\n@Injectable({\n  providedIn: 'root'\n})\n\n// 2. Module level\n@NgModule({\n  providers: [UserService]\n})\n\n// 3. Component level\n@Component({\n  providers: [UserService]\n})</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 102,
    "question": "What is the difference between ngOnInit and constructor in Angular?",
    "answer": "<p>The constructor and ngOnInit serve different purposes in Angular components.</p><h3>Constructor:</h3><ul><li>Called when the class is instantiated</li><li>Used for dependency injection</li><li>Should only be used to initialize class members</li></ul><h3>ngOnInit:</h3><ul><li>Called after the constructor</li><li>Called after Angular has initialized all data-bound properties</li><li>Best place to put initialization logic</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit {\n  // Constructor - for DI only\n  constructor(\n    private userService: UserService,\n    private router: Router\n  ) {}\n\n  // ngOnInit - for initialization\n  ngOnInit() {\n    // Safe to access @Input properties\n    // Safe to make HTTP calls\n    // Safe to initialize component state\n    this.loadData();\n  }\n\n  private loadData() {\n    this.userService.getData().subscribe(data => {\n      // Handle data\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 103,
    "question": "What is the difference between BehaviorSubject and Subject in RxJS?",
    "answer": "<p>BehaviorSubject and Subject are both types of Observables in RxJS, but they have key differences in how they handle data.</p><h3>Subject:</h3><ul><li>Doesn't store the last value</li><li>Subscribers only receive values emitted after they subscribe</li></ul><h3>BehaviorSubject:</h3><ul><li>Stores the last value</li><li>New subscribers receive the last emitted value immediately</li><li>Requires an initial value</li></ul><h3>Example:</h3><pre><code>// Subject Example\nconst subject = new Subject<number>();\nsubject.next(1);\nsubject.next(2);\n\nsubject.subscribe(value => {\n  console.log('Subject:', value); // Only receives 3\n});\nsubject.next(3);\n\n// BehaviorSubject Example\nconst behaviorSubject = new BehaviorSubject<number>(0);\nbehaviorSubject.next(1);\nbehaviorSubject.next(2);\n\nbehaviorSubject.subscribe(value => {\n  console.log('BehaviorSubject:', value); // Receives 2 immediately, then 3\n});\nbehaviorSubject.next(3);</code></pre><h3>Real-world Example:</h3><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  private userSubject = new BehaviorSubject<User | null>(null);\n  user$ = this.userSubject.asObservable();\n\n  setUser(user: User) {\n    this.userSubject.next(user);\n  }\n\n  getUser() {\n    return this.userSubject.value;\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 104,
    "question": "What is Change Detection in Angular and how does it work?",
    "answer": "<p>Change Detection is Angular's mechanism to detect changes in the application state and update the view accordingly.</p><h3>How it Works:</h3><ul><li>Angular creates a change detector for each component</li><li>Checks for changes in component properties</li><li>Updates the view if changes are detected</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-counter',\n  template: `\n    <p>Count: {{ count }}</p>\n    <button (click)='increment()'>Increment</button>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n\n  increment() {\n    this.count++; // Triggers change detection\n  }\n}</code></pre><h3>Change Detection Strategies:</h3><pre><code>// Default strategy (CheckAlways)\n@Component({\n  selector: 'app-default',\n  template: '...'\n})\nexport class DefaultComponent {}\n\n// OnPush strategy\n@Component({\n  selector: 'app-onpush',\n  template: '...',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class OnPushComponent {}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 105,
    "question": "What is NgModule in Angular and what are its main properties?",
    "answer": "<p>NgModule is a decorator that marks a class as an Angular module. It helps organize the application into cohesive blocks of functionality.</p><h3>Main Properties:</h3><ul><li>declarations: Components, directives, and pipes</li><li>imports: Other modules</li><li>providers: Services</li><li>exports: Components, directives, and pipes to be used in other modules</li><li>bootstrap: Root component</li></ul><h3>Example:</h3><pre><code>@NgModule({\n  declarations: [\n    AppComponent,\n    UserComponent,\n    UserListComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    RouterModule\n  ],\n  providers: [\n    UserService,\n    AuthService\n  ],\n  exports: [\n    UserComponent\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }</code></pre><h3>Feature Module Example:</h3><pre><code>@NgModule({\n  declarations: [\n    UserListComponent,\n    UserDetailComponent\n  ],\n  imports: [\n    CommonModule,\n    RouterModule.forChild(userRoutes)\n  ],\n  providers: [UserService]\n})\nexport class UserModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 106,
    "question": "What is the difference between RouterModule.forRoot() and RouterModule.forChild()?",
    "answer": "<p>RouterModule.forRoot() and RouterModule.forChild() are used to configure routing in Angular applications, but they serve different purposes.</p><h3>RouterModule.forRoot():</h3><ul><li>Used in the root module</li><li>Configures the router service</li><li>Should be used only once in the application</li></ul><h3>RouterModule.forChild():</h3><ul><li>Used in feature modules</li><li>Adds additional routes to the existing configuration</li><li>Can be used multiple times</li></ul><h3>Example:</h3><pre><code>// app.module.ts (Root Module)\n@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      { path: '', component: HomeComponent },\n      { path: 'about', component: AboutComponent }\n    ])\n  ]\n})\nexport class AppModule { }\n\n// user.module.ts (Feature Module)\n@NgModule({\n  imports: [\n    RouterModule.forChild([\n      { path: 'users', component: UserListComponent },\n      { path: 'users/:id', component: UserDetailComponent }\n    ])\n  ]\n})\nexport class UserModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 107,
    "question": "What is NgZone in Angular and when should you use it?",
    "answer": "<p>NgZone is a service that helps Angular detect changes by wrapping asynchronous operations. It's useful when working with code outside Angular's zone.</p><h3>Basic Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private ngZone: NgZone) {}\n\n  // Inside Angular zone (default)\n  insideZone() {\n    setTimeout(() => {\n      // This will trigger change detection\n      this.value = 'Updated';\n    }, 1000);\n  }\n\n  // Outside Angular zone\n  outsideZone() {\n    this.ngZone.runOutsideAngular(() => {\n      setTimeout(() => {\n        // This won't trigger change detection\n        this.value = 'Updated';\n        // Manually trigger change detection if needed\n        this.ngZone.run(() => {\n          // Now change detection will run\n        });\n      }, 1000);\n    });\n  }\n}</code></pre><h3>Real-world Example (Performance Optimization):</h3><pre><code>@Component({\n  selector: 'app-chart',\n  template: '...'\n})\nexport class ChartComponent {\n  constructor(private ngZone: NgZone) {}\n\n  initChart() {\n    this.ngZone.runOutsideAngular(() => {\n      // Heavy chart initialization\n      this.chart = new Chart(/* ... */);\n      \n      // Update chart data without triggering change detection\n      this.chart.update();\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 108,
    "question": "What are Guards in Angular and what are their types?",
    "answer": "<p>Guards are interfaces that control access to routes in Angular. They help protect routes from unauthorized access.</p><h3>Types of Guards:</h3><ul><li>CanActivate: Controls if a route can be activated</li><li>CanDeactivate: Controls if a user can leave a route</li><li>Resolve: Resolves data before activating a route</li><li>CanActivateChild: Controls access to child routes</li><li>CanMatch: Controls if a route can be matched</li></ul><h3>Example:</h3><pre><code>// Auth Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) {}\n\n  canActivate(): boolean {\n    if (this.authService.isAuthenticated()) {\n      return true;\n    }\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n\n// Using the guard in routes\nconst routes: Routes = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [AuthGuard]\n  }\n];</code></pre><h3>Deactivate Guard Example:</h3><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class DeactivateGuard implements CanDeactivate<EditComponent> {\n  canDeactivate(\n    component: EditComponent\n  ): boolean | Observable<boolean> {\n    if (component.hasUnsavedChanges()) {\n      return confirm('You have unsaved changes. Leave anyway?');\n    }\n    return true;\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 109,
    "question": "What is a Resolver in Angular and how does it work?",
    "answer": "<p>A Resolver is a service that resolves data before a route is activated. It ensures that data is available before the component is displayed.</p><h3>Basic Example:</h3><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class UserResolver implements Resolve<User> {\n  constructor(private userService: UserService) {}\n\n  resolve(\n    route: ActivatedRouteSnapshot\n  ): Observable<User> | Promise<User> | User {\n    const userId = route.paramMap.get('id');\n    return this.userService.getUser(userId);\n  }\n}\n\n// Using the resolver in routes\nconst routes: Routes = [\n  {\n    path: 'user/:id',\n    component: UserComponent,\n    resolve: {\n      user: UserResolver\n    }\n  }\n];\n\n// Accessing resolved data in component\n@Component({\n  selector: 'app-user',\n  template: '...'\n})\nexport class UserComponent implements OnInit {\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.route.data.subscribe(data => {\n      const user = data['user'];\n      // Use the resolved data\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 110,
    "question": "What are Dynamic Components in Angular and how do you create them?",
    "answer": "<p>Dynamic Components are components that are created and added to the DOM at runtime. They're useful for creating flexible UIs.</p><h3>Example:</h3><pre><code>// Dynamic component\n@Component({\n  selector: 'app-alert',\n  template: `\n    <div class='alert'>\n      <h2>{{ message }}</h2>\n      <button (click)='close()'>Close</button>\n    </div>\n  `\n})\nexport class AlertComponent {\n  @Input() message: string;\n  @Output() close = new EventEmitter<void>();\n}\n\n// Component that creates dynamic components\n@Component({\n  selector: 'app-container',\n  template: '<div #alertContainer></div>'\n})\nexport class ContainerComponent {\n  @ViewChild('alertContainer', { read: ViewContainerRef })\n  container: ViewContainerRef;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}\n\n  createAlert(message: string) {\n    // Clear previous alerts\n    this.container.clear();\n\n    // Create component\n    const factory = this.componentFactoryResolver\n      .resolveComponentFactory(AlertComponent);\n    const componentRef = this.container.createComponent(factory);\n\n    // Set inputs\n    componentRef.instance.message = message;\n\n    // Handle outputs\n    componentRef.instance.close.subscribe(() => {\n      componentRef.destroy();\n    });\n  }\n}</code></pre><h3>Using the Dynamic Component:</h3><pre><code>// In the module\n@NgModule({\n  declarations: [AlertComponent],\n  entryComponents: [AlertComponent]\n})\nexport class AppModule { }\n\n// In the template\n<button (click)='createAlert(\"Hello!\")'>Show Alert</button></code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 111,
    "question": "What is Module Federation in Angular and how does it work?",
    "answer": "<p>Module Federation is a feature that allows you to dynamically load modules from different applications at runtime. It's useful for micro-frontend architectures.</p><h3>Basic Setup:</h3><pre><code>// webpack.config.js (Host Application)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        mfe1: 'mfe1@http://localhost:3000/remoteEntry.js'\n      },\n      shared: ['@angular/core', '@angular/common']\n    })\n  ]\n};\n\n// webpack.config.js (Remote Application)\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'mfe1',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './Component': './src/app/component'\n      },\n      shared: ['@angular/core', '@angular/common']\n    })\n  ]\n};</code></pre><h3>Using Remote Components:</h3><pre><code>// app.module.ts\n@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      {\n        path: 'mfe1',\n        loadChildren: () => import('mfe1/Component')\n      }\n    ])\n  ]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 112,
    "question": "What is the difference between ng-template, ng-container, and ng-content?",
    "answer": "<p>These three directives serve different purposes in Angular templates.</p><h3>ng-template:</h3><ul><li>Defines a template that can be reused</li><li>Not rendered by default</li><li>Used with structural directives</li></ul><h3>ng-container:</h3><ul><li>Grouping element that doesn't add to the DOM</li><li>Useful for applying multiple structural directives</li></ul><h3>ng-content:</h3><ul><li>Projects content from parent to child</li><li>Used for content projection</li></ul><h3>Examples:</h3><pre><code>// ng-template example\n<ng-template #loading>\n  <div>Loading...</div>\n</ng-template>\n\n<div *ngIf='isLoading; else loading'>\n  Content\n</div>\n\n// ng-container example\n<ng-container *ngIf='isLoggedIn'>\n  <div>Welcome</div>\n  <div>Profile</div>\n</ng-container>\n\n// ng-content example\n// parent.component.html\n<app-card>\n  <h1>Title</h1>\n  <p>Content</p>\n</app-card>\n\n// card.component.html\n<div class='card'>\n  <ng-content></ng-content>\n</div></code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 113,
    "question": "What is the difference between ViewChild and ContentChild?",
    "answer": "<p>ViewChild and ContentChild are decorators used to access child elements, but they work in different contexts.</p><h3>ViewChild:</h3><ul><li>Accesses elements in the component's view</li><li>Available after view initialization</li></ul><h3>ContentChild:</h3><ul><li>Accesses projected content</li><li>Available after content initialization</li></ul><h3>Example:</h3><pre><code>// Parent Component\n@Component({\n  selector: 'app-parent',\n  template: `\n    <div #viewChild>View Child</div>\n    <app-child>\n      <div #contentChild>Content Child</div>\n    </app-child>\n  `\n})\nexport class ParentComponent implements AfterViewInit, AfterContentInit {\n  @ViewChild('viewChild') viewChild: ElementRef;\n  @ContentChild('contentChild') contentChild: ElementRef;\n\n  ngAfterViewInit() {\n    // ViewChild is available here\n    console.log(this.viewChild);\n  }\n\n  ngAfterContentInit() {\n    // ContentChild is available here\n    console.log(this.contentChild);\n  }\n}\n\n// Child Component\n@Component({\n  selector: 'app-child',\n  template: '<ng-content></ng-content>'\n})\nexport class ChildComponent {}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 114,
    "question": "What is OnPush Change Detection and when should you use it?",
    "answer": "<p>OnPush is a change detection strategy that improves performance by only checking for changes when inputs change or events occur.</p><h3>Basic Example:</h3><pre><code>@Component({\n  selector: 'app-user',\n  template: `\n    <div>{{ user.name }}</div>\n    <div>{{ user.email }}</div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserComponent {\n  @Input() user: User;\n\n  // Change detection will run when:\n  // 1. @Input() properties change\n  // 2. Events occur in the template\n  // 3. Observable emits in the template\n  // 4. ChangeDetectorRef.detectChanges() is called\n}</code></pre><h3>Working with OnPush:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ExampleComponent {\n  constructor(\n    private cdr: ChangeDetectorRef,\n    private userService: UserService\n  ) {}\n\n  updateUser() {\n    this.userService.getUser().subscribe(user => {\n      this.user = user;\n      // Manually trigger change detection\n      this.cdr.detectChanges();\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 115,
    "question": "How do you handle memory leaks in Angular?",
    "answer": "<p>Memory leaks in Angular often occur due to unmanaged subscriptions and event listeners. Here are common solutions.</p><h3>Common Causes and Solutions:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    // Using takeUntil\n    this.userService.getUsers()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(users => {\n        // Handle users\n      });\n\n    // Using async pipe (preferred)\n    this.users$ = this.userService.getUsers();\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre><h3>Template Example:</h3><pre><code>// Using async pipe (automatically handles subscription)\n<ng-container *ngIf='users$ | async as users'>\n  <div *ngFor='let user of users'>\n    {{ user.name }}\n  </div>\n</ng-container></code></pre><h3>Event Listener Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  private resizeListener: () => void;\n\n  ngOnInit() {\n    this.resizeListener = () => {\n      // Handle resize\n    };\n    window.addEventListener('resize', this.resizeListener);\n  }\n\n  ngOnDestroy() {\n    window.removeEventListener('resize', this.resizeListener);\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 116,
    "question": "What are Standalone Components in Angular?",
    "answer": "<p>Standalone Components are a new feature in Angular that allows you to create components without declaring them in an NgModule.</p><h3>Basic Example:</h3><pre><code>@Component({\n  selector: 'app-standalone',\n  template: '...',\n  standalone: true,\n  imports: [CommonModule, RouterModule]\n})\nexport class StandaloneComponent {}\n\n// Using in routes\nconst routes: Routes = [\n  {\n    path: 'standalone',\n    loadComponent: () => import('./standalone.component')\n      .then(m => m.StandaloneComponent)\n  }\n];</code></pre><h3>With Dependencies:</h3><pre><code>@Component({\n  selector: 'app-user-list',\n  template: `\n    <div *ngFor='let user of users$ | async'>\n      {{ user.name }}\n    </div>\n  `,\n  standalone: true,\n  imports: [CommonModule, UserCardComponent],\n  providers: [UserService]\n})\nexport class UserListComponent {\n  users$ = this.userService.getUsers();\n\n  constructor(private userService: UserService) {}\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 117,
    "question": "What is Angular Universal and how do you implement it?",
    "answer": "<p>Angular Universal is a technology that renders Angular applications on the server. It improves performance and SEO.</p><h3>Basic Setup:</h3><pre><code>// app.module.ts\n@NgModule({\n  imports: [\n    BrowserModule.withServerTransition({ appId: 'my-app' }),\n    ServerModule\n  ]\n})\nexport class AppModule { }\n\n// app.server.module.ts\n@NgModule({\n  imports: [\n    AppModule,\n    ServerModule\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppServerModule { }</code></pre><h3>Server-side Rendering Example:</h3><pre><code>// app.component.ts\n@Component({\n  selector: 'app-root',\n  template: `\n    <div>\n      <h1>{{ title }}</h1>\n      <div *ngIf='isBrowser'>Browser only content</div>\n    </div>\n  `\n})\nexport class AppComponent {\n  title = 'My App';\n  isBrowser: boolean;\n\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n}</code></pre><h3>Running the Application:</h3><pre><code>// package.json\n{\n  \"scripts\": {\n    \"dev:ssr\": \"ng run my-app:serve-ssr\",\n    \"build:ssr\": \"ng build && ng run my-app:server\",\n    \"serve:ssr\": \"node dist/my-app/server/main.js\"\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 118,
    "question": "What are Pipes in Angular and how do you create custom pipes?",
    "answer": "<p>Pipes are used to transform data in templates. Angular provides built-in pipes and allows you to create custom ones.</p><h3>Built-in Pipes Example:</h3><pre><code>// Using built-in pipes\n<div>{{ date | date:'short' }}</div>\n<div>{{ price | currency:'USD' }}</div>\n<div>{{ text | uppercase }}</div>\n<div>{{ items | slice:0:2 }}</div></code></pre><h3>Custom Pipe Example:</h3><pre><code>@Pipe({\n  name: 'truncate'\n})\nexport class TruncatePipe implements PipeTransform {\n  transform(value: string, limit: number = 100): string {\n    if (!value) return '';\n    return value.length > limit\n      ? value.substring(0, limit) + '...'\n      : value;\n  }\n}\n\n// Using the custom pipe\n<div>{{ longText | truncate:50 }}</div></code></pre><h3>Pure vs Impure Pipes:</h3><pre><code>@Pipe({\n  name: 'filter',\n  pure: false // Impure pipe\n})\nexport class FilterPipe implements PipeTransform {\n  transform(items: any[], filter: string): any[] {\n    if (!items || !filter) return items;\n    return items.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 119,
    "question": "What are Angular Lifecycle Hooks and when should you use them?",
    "answer": "<p>Lifecycle hooks are methods that Angular calls at specific points in a component's lifecycle.</p><h3>Common Lifecycle Hooks:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements\n  OnInit,\n  OnDestroy,\n  AfterViewInit,\n  AfterContentInit {\n\n  // Called after data-bound properties are initialized\n  ngOnInit() {\n    // Initialize component\n  }\n\n  // Called before the component is destroyed\n  ngOnDestroy() {\n    // Clean up resources\n  }\n\n  // Called after the view is initialized\n  ngAfterViewInit() {\n    // Access ViewChild\n  }\n\n  // Called after content is projected\n  ngAfterContentInit() {\n    // Access ContentChild\n  }\n\n  // Called when data-bound properties change\n  ngOnChanges(changes: SimpleChanges) {\n    // Handle changes\n  }\n\n  // Called after every change detection run\n  ngDoCheck() {\n    // Custom change detection\n  }\n}</code></pre><h3>Real-world Example:</h3><pre><code>@Component({\n  selector: 'app-user-profile',\n  template: '...'\n})\nexport class UserProfileComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    // Load user data\n    this.userService.getUser()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(user => {\n        // Handle user data\n      });\n  }\n\n  ngOnDestroy() {\n    // Clean up subscriptions\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 120,
    "question": "What is the Injector in Angular and how does it work?",
    "answer": "<p>The Injector is responsible for creating instances of dependencies and maintaining a single instance of each dependency within its scope.</p><h3>Basic Example:</h3><pre><code>// Service\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor() {}\n  getUsers() { return []; }\n}\n\n// Component\n@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private injector: Injector) {\n    // Get service instance\n    const userService = this.injector.get(UserService);\n  }\n}</code></pre><h3>Custom Injector Example:</h3><pre><code>@Component({\n  selector: 'app-parent',\n  template: '...'\n})\nexport class ParentComponent {\n  constructor(private injector: Injector) {}\n\n  createChildComponent() {\n    const childInjector = Injector.create({\n      providers: [\n        { provide: UserService, useClass: MockUserService }\n      ],\n      parent: this.injector\n    });\n\n    const childComponent = createComponent(ChildComponent, {\n      elementInjector: childInjector\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 121,
    "question": "What is trackBy in Angular and why should you use it?",
    "answer": "<p>trackBy is a function used with *ngFor to optimize rendering performance by helping Angular track items in a list.</p><h3>Why Use trackBy:</h3><ul><li>Improves performance with large lists</li><li>Prevents unnecessary DOM updates</li><li>Maintains component state</li></ul><h3>Example:</h3><pre><code>// Without trackBy\n<div *ngFor='let user of users'>\n  {{ user.name }}\n</div>\n\n// With trackBy\n<div *ngFor='let user of users; trackBy: trackByFn'>\n  {{ user.name }}\n</div>\n\n// In component\ntrackByFn(index: number, item: User): number {\n  return item.id; // or any unique identifier\n}</code></pre><h3>Real-world Example:</h3><pre><code>@Component({\n  selector: 'app-user-list',\n  template: `\n    <div *ngFor='let user of users; trackBy: trackByFn'>\n      <app-user-card [user]='user'></app-user-card>\n    </div>\n  `\n})\nexport class UserListComponent {\n  users: User[] = [];\n\n  trackByFn(index: number, user: User): number {\n    return user.id;\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 122,
    "question": "What are Preloading Strategies in Angular and how do they work?",
    "answer": "<p>Preloading strategies determine how Angular loads lazy-loaded modules. They help balance between initial load time and user experience.</p><h3>Types of Preloading Strategies:</h3><ul><li>NoPreloading (default)</li><li>PreloadAllModules</li><li>Custom strategies</li></ul><h3>Example:</h3><pre><code>// Using PreloadAllModules\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules\n    })\n  ]\n})\nexport class AppModule { }\n\n// Custom Preloading Strategy\n@Injectable({\n  providedIn: 'root'\n})\nexport class CustomPreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    if (route.data && route.data['preload']) {\n      return load();\n    }\n    return of(null);\n  }\n}\n\n// Using custom strategy\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module'),\n    data: { preload: true }\n  }\n];</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 123,
    "question": "What is the difference between Renderer2 and ElementRef in Angular?",
    "answer": "<p>Renderer2 and ElementRef are both used to manipulate the DOM, but they serve different purposes and have different security implications.</p><h3>ElementRef:</h3><ul><li>Direct access to DOM element</li><li>Less secure</li><li>Should be used carefully</li></ul><h3>Renderer2:</h3><ul><li>Platform-agnostic DOM manipulation</li><li>More secure</li><li>Recommended approach</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '<div #myDiv></div>'\n})\nexport class ExampleComponent {\n  @ViewChild('myDiv') div: ElementRef;\n\n  constructor(private renderer: Renderer2) {}\n\n  // Using ElementRef (not recommended)\n  updateWithElementRef() {\n    this.div.nativeElement.style.backgroundColor = 'red';\n  }\n\n  // Using Renderer2 (recommended)\n  updateWithRenderer() {\n    this.renderer.setStyle(\n      this.div.nativeElement,\n      'backgroundColor',\n      'red'\n    );\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 124,
    "question": "How do you secure an Angular application?",
    "answer": "<p>Securing an Angular application involves multiple layers of protection.</p><h3>Key Security Measures:</h3><ul><li>Use HTTPS</li><li>Implement authentication</li><li>Prevent XSS attacks</li><li>Use Content Security Policy</li><li>Implement proper CORS</li></ul><h3>Example:</h3><pre><code>// HTTP Interceptor for Authentication\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    const token = this.authService.getToken();\n    \n    if (token) {\n      const authReq = req.clone({\n        headers: req.headers.set('Authorization', `Bearer ${token}`)\n      });\n      return next.handle(authReq);\n    }\n    return next.handle(req);\n  }\n}\n\n// Content Security Policy\n// index.html\n<meta http-equiv='Content-Security-Policy'\n  content=\"default-src 'self'; script-src 'self' 'unsafe-inline';\">\n\n// Sanitizing user input\n@Component({\n  selector: 'app-example',\n  template: '<div [innerHTML]='sanitizedContent'></div>'\n})\nexport class ExampleComponent {\n  constructor(private sanitizer: DomSanitizer) {}\n\n  sanitizeContent(content: string) {\n    return this.sanitizer.bypassSecurityTrustHtml(content);\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 125,
    "question": "What is a Progressive Web App (PWA) in Angular and how do you implement it?",
    "answer": "<p>A PWA is a web application that can work offline and provide a native app-like experience.</p><h3>Key Features:</h3><ul><li>Offline functionality</li><li>Push notifications</li><li>Installable on devices</li></ul><h3>Implementation:</h3><pre><code>// 1. Add PWA support\nng add @angular/pwa\n\n// 2. Configure manifest.webmanifest\n{\n  \"name\": \"My PWA App\",\n  \"short_name\": \"PWA App\",\n  \"theme_color\": \"#1976d2\",\n  \"background_color\": \"#fafafa\",\n  \"display\": \"standalone\",\n  \"scope\": \"./\",\n  \"start_url\": \"./\",\n  \"icons\": [\n    {\n      \"src\": \"assets/icons/icon-72x72.png\",\n      \"sizes\": \"72x72\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n\n// 3. Service Worker Registration\n// app.module.ts\n@NgModule({\n  imports: [\n    ServiceWorkerModule.register('ngsw-worker.js', {\n      enabled: environment.production\n    })\n  ]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 126,
    "question": "What is Tree Shaking in Angular and how does it work?",
    "answer": "<p>Tree shaking is a process that removes unused code from the final bundle, reducing the application size.</p><h3>How it Works:</h3><ul><li>Analyzes code dependencies</li><li>Removes unused exports</li><li>Works with ES modules</li></ul><h3>Example:</h3><pre><code>// This will be included\nimport { Component } from '@angular/core';\n\n// This might be tree-shaken if unused\nimport { unused } from './unused';\n\n@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  // Only used code is included\n  usedMethod() {\n    // Implementation\n  }\n}\n\n// This will be tree-shaken\nfunction unusedFunction() {\n  // Implementation\n}</code></pre><h3>Best Practices:</h3><pre><code>// Use named exports\n// Good - can be tree-shaken\nexport const used = 'used';\nexport const unused = 'unused';\n\n// Bad - can't be tree-shaken\nexport default {\n  used: 'used',\n  unused: 'unused'\n};</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 127,
    "question": "How do you optimize initial performance in an Angular application?",
    "answer": "<p>Optimizing initial performance involves several strategies to reduce load time and improve user experience.</p><h3>Key Optimization Techniques:</h3><ul><li>Lazy loading</li><li>Preloading strategies</li><li>Bundle optimization</li><li>Server-side rendering</li></ul><h3>Example:</h3><pre><code>// 1. Lazy Loading\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module')\n  }\n];\n\n// 2. Bundle Optimization\n// angular.json\n{\n  \"optimization\": {\n    \"scripts\": true,\n    \"styles\": true,\n    \"fonts\": true\n  }\n}\n\n// 3. Preloading Strategy\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules\n    })\n  ]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 128,
    "question": "What is the difference between ActivatedRoute and Router in Angular?",
    "answer": "<p>ActivatedRoute and Router serve different purposes in Angular routing.</p><h3>ActivatedRoute:</h3><ul><li>Accesses route parameters</li><li>Gets route data</li><li>Accesses child routes</li></ul><h3>Router:</h3><ul><li>Navigates between routes</li><li>Manages route configuration</li><li>Handles route events</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit {\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router\n  ) {}\n\n  ngOnInit() {\n    // Using ActivatedRoute\n    this.route.params.subscribe(params => {\n      const id = params['id'];\n    });\n\n    this.route.data.subscribe(data => {\n      const resolvedData = data['resolvedData'];\n    });\n  }\n\n  // Using Router\n  navigateToUser(id: number) {\n    this.router.navigate(['/users', id]);\n  }\n\n  navigateWithQuery() {\n    this.router.navigate(['/users'], {\n      queryParams: { filter: 'active' }\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 129,
    "question": "What are the different types of Route Guards in Angular?",
    "answer": "<p>Route Guards are interfaces that control access to routes in Angular.</p><h3>Types of Guards:</h3><ul><li>CanActivate</li><li>CanDeactivate</li><li>Resolve</li><li>CanActivateChild</li><li>CanMatch</li></ul><h3>Example:</h3><pre><code>// CanActivate Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  canActivate(): boolean {\n    return this.authService.isAuthenticated();\n  }\n}\n\n// CanDeactivate Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class UnsavedChangesGuard implements CanDeactivate<EditComponent> {\n  canDeactivate(component: EditComponent): boolean {\n    if (component.hasUnsavedChanges()) {\n      return confirm('You have unsaved changes. Leave anyway?');\n    }\n    return true;\n  }\n}\n\n// Resolve Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserResolver implements Resolve<User> {\n  resolve(): Observable<User> {\n    return this.userService.getUser();\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 130,
    "question": "What is Server-Side Rendering (SSR) in Angular and how do you implement it?",
    "answer": "<p>SSR renders Angular applications on the server, improving initial load time and SEO.</p><h3>Implementation:</h3><pre><code>// 1. Add SSR support\nng add @nguniversal/express-engine\n\n// 2. app.server.module.ts\n@NgModule({\n  imports: [\n    AppModule,\n    ServerModule\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppServerModule { }\n\n// 3. app.component.ts\n@Component({\n  selector: 'app-root',\n  template: `\n    <div>\n      <h1>{{ title }}</h1>\n      <div *ngIf='isBrowser'>Browser only content</div>\n    </div>\n  `\n})\nexport class AppComponent {\n  isBrowser: boolean;\n\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n}\n\n// 4. Running the application\n// package.json\n{\n  \"scripts\": {\n    \"dev:ssr\": \"ng run my-app:serve-ssr\",\n    \"build:ssr\": \"ng build && ng run my-app:server\",\n    \"serve:ssr\": \"node dist/my-app/server/main.js\"\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 131,
    "question": "What is the difference between AOT and JIT compilation in Angular?",
    "answer": "<p>AOT (Ahead-of-Time) and JIT (Just-in-Time) are two different ways Angular compiles your application.</p><h3>Key Differences:</h3><ul><li>AOT compiles at build time</li><li>JIT compiles at runtime</li><li>AOT is faster and more secure</li><li>JIT is better for development</li></ul><h3>Example:</h3><pre><code>// AOT Compilation (Production)\n// angular.json\n{\n  \"configurations\": {\n    \"production\": {\n      \"aot\": true,\n      \"optimization\": true\n    }\n  }\n}\n\n// JIT Compilation (Development)\n// main.ts\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n// AOT Compilation\n// main.ts\nplatformBrowser().bootstrapModule(AppModule);</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 132,
    "question": "What is the difference between providedIn: 'root' and @NgModule.providers?",
    "answer": "<p>Both approaches provide services in Angular, but they have different scopes and use cases.</p><h3>providedIn: 'root':</h3><ul><li>Singleton service</li><li>Available application-wide</li><li>Tree-shakeable</li></ul><h3>@NgModule.providers:</h3><ul><li>Module-scoped service</li><li>Can have multiple instances</li><li>Not tree-shakeable</li></ul><h3>Example:</h3><pre><code>// Root-level service\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  // Available everywhere\n}\n\n// Module-level service\n@Injectable()\nexport class ModuleService {\n  // Only available in this module\n}\n\n@NgModule({\n  providers: [ModuleService]\n})\nexport class FeatureModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 133,
    "question": "How do you architect a large-scale Angular application?",
    "answer": "<p>Architecting a large-scale Angular application requires careful planning and organization.</p><h3>Key Principles:</h3><ul><li>Feature modules</li><li>Lazy loading</li><li>Shared modules</li><li>Core module</li><li>State management</li></ul><h3>Example Structure:</h3><pre><code>src/\n  app/\n    core/\n      services/\n      guards/\n      interceptors/\n    shared/\n      components/\n      directives/\n      pipes/\n    features/\n      auth/\n      users/\n      products/\n    app.module.ts\n    app-routing.module.ts\n\n// Core Module\n@NgModule({\n  providers: [\n    AuthService,\n    AuthGuard,\n    HTTP_INTERCEPTORS\n  ]\n})\nexport class CoreModule { }\n\n// Shared Module\n@NgModule({\n  declarations: [\n    SharedComponent,\n    SharedDirective,\n    SharedPipe\n  ],\n  exports: [\n    SharedComponent,\n    SharedDirective,\n    SharedPipe\n  ]\n})\nexport class SharedModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 134,
    "question": "What are some commonly used RxJS operators in Angular?",
    "answer": "<p>RxJS operators are used to transform, filter, and combine observables in Angular.</p><h3>Common Operators:</h3><ul><li>map</li><li>filter</li><li>switchMap</li><li>catchError</li><li>debounceTime</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private userService: UserService) {}\n\n  // Using map\n  getUsers() {\n    return this.userService.getUsers().pipe(\n      map(users => users.map(user => user.name))\n    );\n  }\n\n  // Using switchMap\n  getUserDetails(id: number) {\n    return this.userService.getUser(id).pipe(\n      switchMap(user => this.userService.getUserDetails(user.id))\n    );\n  }\n\n  // Using debounceTime\n  searchUsers(term: string) {\n    return this.userService.searchUsers(term).pipe(\n      debounceTime(300),\n      distinctUntilChanged()\n    );\n  }\n\n  // Using catchError\n  getData() {\n    return this.userService.getData().pipe(\n      catchError(error => {\n        console.error('Error:', error);\n        return of([]);\n      })\n    );\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 135,
    "question": "What is takeUntil in RxJS and how do you use it?",
    "answer": "<p>takeUntil is an RxJS operator used to automatically unsubscribe from observables when a component is destroyed.</p><h3>Usage:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    // Using takeUntil\n    this.userService.getUsers()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(users => {\n        // Handle users\n      });\n\n    // Multiple subscriptions\n    this.userService.getData()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(data => {\n        // Handle data\n      });\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre><h3>Alternative Approach:</h3><pre><code>// Using async pipe (preferred)\n@Component({\n  selector: 'app-example',\n  template: `\n    <div *ngIf='users$ | async as users'>\n      <div *ngFor='let user of users'>\n        {{ user.name }}\n      </div>\n    </div>\n  `\n})\nexport class ExampleComponent {\n  users$ = this.userService.getUsers();\n\n  constructor(private userService: UserService) {}\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 136,
    "question": "Introduction",
    "answer": "<p><strong>My name is Jimit Hothi, and I have over 9 years of experience in the software development industry.</strong> I have worked on multiple domains and technologies. specializing in JavaScript and Node.js and building scalable, secure, and high-performance web applications.</p><p>I have hands-on experience in <strong>both frontend and backend development</strong>. On the frontend, I'm proficient with modern frameworks like <strong>Angular, React </strong>, while on the backend, I develop <strong>RESTful APIs</strong> and services using <strong>Node.js</strong>.</p><p>In terms of cloud experience, I have worked with <strong>Google Cloud Functions</strong> to build and deploy serverless solutions and microservices. I also have experience with Amazon Web Services (AWS), including services like Lambda, S3, CloudWatch, and EC2, for managing cloud infrastructure, deployment automation, and monitoring.</p><p>Throughout my career, I have contributed to various phases of the software development lifecycle—from requirement gathering and system design to development, testing, deployment, and maintenance. I’ve also handled responsibilities such as team coordination, client communication, code reviews, and project delivery.</p><p>I’m comfortable working both independently and collaboratively in agile environments.</p>",
    "category": "General",
    "difficulty": "Intermediate"
  },
  {
    "id": 137,
    "question": "What is Git and what are its main features?",
    "answer": "<p>Git is a distributed version control system that helps track changes in source code during software development.</p><h3>Key Features:</h3><ul><li>Distributed Version Control</li><li>Branching and Merging</li><li>Staging Area</li><li>Data Integrity</li><li>Speed and Performance</li></ul><h3>Basic Git Commands:</h3><pre><code># Initialize a new repository\n$ git init\n\n# Clone a repository\n$ git clone https://github.com/username/repository.git\n\n# Check repository status\n$ git status\n\n# Add files to staging area\n$ git add filename.txt\n$ git add .  # Add all files\n\n# Commit changes\n$ git commit -m \"Your commit message\"\n\n# Push changes to remote\n$ git push origin main</code></pre>",
    "category": "Git",
    "difficulty": "Beginner"
  },
  {
    "id": 138,
    "question": "What is the difference between git pull and git fetch?",
    "answer": "<p>git pull and git fetch are both used to get updates from a remote repository, but they work differently.</p><h3>git fetch:</h3><ul><li>Downloads new data from remote repository</li><li>Doesn't integrate changes into your working files</li><li>Safer option as it doesn't modify your local work</li></ul><h3>git pull:</h3><ul><li>Downloads AND integrates changes from remote repository</li><li>Combines git fetch + git merge</li><li>Can potentially cause conflicts</li></ul><h3>Example:</h3><pre><code># Using git fetch\n$ git fetch origin\n$ git merge origin/main\n\n# Using git pull (does both fetch and merge)\n$ git pull origin main</code></pre><h3>Best Practice:</h3><p>Use git fetch when you want to review changes before integrating them. Use git pull when you're confident about the remote changes and want to integrate them immediately.</p>",
    "category": "Git",
    "difficulty": "Intermediate"
  },
  {
    "id": 139,
    "question": "How do you resolve merge conflicts in Git?",
    "answer": "<p>Merge conflicts occur when Git can't automatically resolve differences between commits. Here's how to handle them:</p><h3>Steps to Resolve Conflicts:</h3><ol><li>Identify conflicting files</li><li>Open and edit the files</li><li>Choose which changes to keep</li><li>Mark conflicts as resolved</li><li>Complete the merge</li></ol><h3>Example Process:</h3><pre><code># When you see a conflict, Git marks the file like this:\n<<<<<<< HEAD\nYour changes\n=======\nChanges from other branch\n>>>>>>> branch-name\n\n# After editing, mark as resolved:\n$ git add filename.txt\n\n# Complete the merge:\n$ git commit -m \"Resolved merge conflicts\"</code></pre><h3>Best Practices:</h3><ul><li>Always pull latest changes before starting new work</li><li>Keep commits small and focused</li><li>Communicate with team members about changes</li><li>Use visual merge tools for complex conflicts</li></ul>",
    "category": "Git",
    "difficulty": "Intermediate"
  },
  {
    "id": 140,
    "question": "What is Git branching strategy and what are common branching models?",
    "answer": "<p>A branching strategy defines how branches are created and managed in a project. Here are common strategies:</p><h3>Git Flow:</h3><ul><li>main - production code</li><li>develop - development branch</li><li>feature/* - new features</li><li>release/* - release preparation</li><li>hotfix/* - urgent fixes</li></ul><h3>GitHub Flow:</h3><ul><li>main - always deployable</li><li>feature branches - for new work</li><li>Pull requests for review</li><li>Merge after approval</li></ul><h3>Example Commands:</h3><pre><code># Create and switch to new branch\n$ git checkout -b feature/new-feature\n\n# Switch between branches\n$ git checkout main\n\n# Merge branch\n$ git merge feature/new-feature\n\n# Delete branch\n$ git branch -d feature/new-feature</code></pre><h3>Best Practices:</h3><ul><li>Use meaningful branch names</li><li>Keep branches short-lived</li><li>Regularly sync with main branch</li><li>Delete branches after merging</li></ul>",
    "category": "Git",
    "difficulty": "Advanced"
  },
  {
    "id": 141,
    "question": "What is Git rebase and when should you use it?",
    "answer": "<p>Git rebase is a command that helps maintain a linear project history by moving or combining commits.</p><h3>Key Points:</h3><ul><li>Rewrites commit history</li><li>Creates a linear project history</li><li>Should be used before pushing to shared branches</li></ul><h3>Example:</h3><pre><code># Basic rebase\n$ git checkout feature-branch\n$ git rebase main\n\n# Interactive rebase (last 3 commits)\n$ git rebase -i HEAD~3\n\n# During interactive rebase, you can:\n# - pick: keep commit as is\n# - reword: change commit message\n# - edit: modify commit\n# - squash: combine with previous commit\n# - fixup: combine and discard message\n# - drop: remove commit</code></pre><h3>Best Practices:</h3><ul><li>Don't rebase commits that have been pushed to public repositories</li><li>Use rebase to keep feature branches up to date with main</li><li>Use interactive rebase to clean up local commits before pushing</li></ul>",
    "category": "Git",
    "difficulty": "Advanced"
  },
  {
    "id": 142,
    "question": "What is Git stash and how do you use it?",
    "answer": "<p>Git stash temporarily saves your uncommitted changes, allowing you to switch branches without committing incomplete work.</p><h3>Common Stash Commands:</h3><pre><code># Save changes to stash\n$ git stash save \"Work in progress\"\n\n# List all stashes\n$ git stash list\n\n# Apply most recent stash\n$ git stash apply\n\n# Apply specific stash\n$ git stash apply stash@{2}\n\n# Apply and remove stash\n$ git stash pop\n\n# Remove specific stash\n$ git stash drop stash@{1}\n\n# Clear all stashes\n$ git stash clear</code></pre><h3>Best Practices:</h3><ul><li>Use descriptive messages when stashing</li><li>Regularly clean up old stashes</li><li>Consider using git stash push -m \"message\" for better organization</li><li>Use git stash branch to create a new branch from a stash</li></ul>",
    "category": "Git",
    "difficulty": "Intermediate"
  },
  {
    "id": 143,
    "question": "What are Git hooks and how do you use them?",
    "answer": "<p>Git hooks are scripts that run automatically at specific points in the Git workflow.</p><h3>Common Hooks:</h3><ul><li>pre-commit: Runs before commit is created</li><li>post-commit: Runs after commit is created</li><li>pre-push: Runs before code is pushed</li><li>pre-rebase: Runs before rebase starts</li></ul><h3>Example pre-commit hook:</h3><pre><code>#!/bin/sh\n\n# Run linter\nnpm run lint\n\n# Run tests\nnpm test\n\n# If any command fails, prevent commit\nif [ $? -ne 0 ]; then\n  echo \"Tests must pass before commit!\"\n  exit 1\nfi</code></pre><h3>Setting up hooks:</h3><pre><code># Create hook file\n$ touch .git/hooks/pre-commit\n\n# Make it executable\n$ chmod +x .git/hooks/pre-commit\n\n# Using Husky (popular hook manager)\n$ npm install husky --save-dev\n\n# Configure in package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm run lint\",\n      \"pre-push\": \"npm test\"\n    }\n  }\n}</code></pre>",
    "category": "Git",
    "difficulty": "Advanced"
  },
  {
    "id": 144,
    "question": "How do you undo changes in Git?",
    "answer": "<p>Git provides several ways to undo changes depending on the situation.</p><h3>Common Scenarios:</h3><pre><code># Undo working directory changes\n$ git checkout -- filename.txt\n\n# Unstage changes (keep working directory)\n$ git reset HEAD filename.txt\n\n# Undo last commit (keep changes staged)\n$ git reset --soft HEAD~1\n\n# Undo last commit (keep changes in working directory)\n$ git reset HEAD~1\n\n# Undo last commit (discard changes)\n$ git reset --hard HEAD~1\n\n# Revert a specific commit\n$ git revert commit-hash\n\n# Amend last commit\n$ git commit --amend -m \"New commit message\"</code></pre><h3>Best Practices:</h3><ul><li>Use git reset for local changes</li><li>Use git revert for pushed commits</li><li>Always create a backup branch before major undo operations</li><li>Be careful with --hard reset as it permanently deletes changes</li></ul>",
    "category": "Git",
    "difficulty": "Intermediate"
  },
  {
    "id": 145,
    "question": "What is Git submodule and when should you use it?",
    "answer": "<p>Git submodules allow you to include other Git repositories within your project.</p><h3>Common Use Cases:</h3><ul><li>Including shared libraries</li><li>Managing third-party dependencies</li><li>Organizing large projects</li></ul><h3>Basic Commands:</h3><pre><code># Add a submodule\n$ git submodule add https://github.com/username/repo.git path/to/submodule\n\n# Initialize submodules after cloning\n$ git submodule init\n$ git submodule update\n\n# Clone repository with submodules\n$ git clone --recursive https://github.com/username/repo.git\n\n# Update all submodules\n$ git submodule update --remote\n\n# Remove submodule\n$ git submodule deinit path/to/submodule\n$ git rm path/to/submodule</code></pre><h3>Best Practices:</h3><ul><li>Use submodules for stable, versioned dependencies</li><li>Document submodule usage in README</li><li>Consider using package managers for simpler dependency management</li><li>Keep submodules up to date</li></ul>",
    "category": "Git",
    "difficulty": "Advanced"
  },
  {
    "id": 146,
    "question": "Provide All git commands",
    "answer": "<pre><code># Repository Setup\ngit init // Git initialization - creates a new Git repository\ngit clone <repo-url> // Clone remote repository to local machine\n\n# Basic Snapshotting\ngit status // Show working tree status\ngit add <file> // Add file to staging area\ngit add . // Add all files to staging area\ngit commit -m \"Commit message\" // Create commit with message\ngit commit --amend // Modify last commit\n\n# Branching and Merging\ngit branch // List all branches\ngit branch <branch-name> // Create new branch\ngit checkout <branch-name> // Switch to branch\ngit checkout -b <new-branch> // Create and switch to new branch\ngit merge <branch> // Merge branch into current branch\ngit rebase <branch> // Rebase current branch onto another\ngit branch -d <branch> // Delete branch\n\n# Remote Repositories\ngit remote -v // Show remote repositories\ngit remote add origin <url> // Add remote repository\ngit fetch // Download objects from remote\ngit pull // Fetch and merge from remote\ngit pull origin <branch> // Pull specific branch from remote\ngit push // Push commits to remote\ngit push -u origin <branch> // Push and set upstream branch\n\n# Undoing Changes\ngit checkout -- <file> // Discard changes in working directory\ngit reset HEAD <file> // Unstage file\ngit reset --soft HEAD~1 // Undo commit, keep changes staged\ngit reset --hard HEAD~1 // Undo commit and discard changes\ngit revert <commit-hash> // Create new commit that undoes changes\n\n# Logs and History\ngit log // Show commit history\ngit log --oneline // Show compact commit history\ngit show <commit> // Show commit details\ngit diff // Show unstaged changes\ngit diff --staged // Show staged changes\n\n# Stash\ngit stash // Temporarily save changes\ngit stash list // List all stashes\ngit stash apply // Apply most recent stash\ngit stash pop // Apply and remove stash\ngit stash drop // Delete specific stash\ngit stash clear // Delete all stashes\n\n# Tags\ngit tag // List all tags\ngit tag <tagname> // Create lightweight tag\ngit tag -a <tagname> -m \"message\" // Create annotated tag\ngit push origin <tagname> // Push tag to remote\n\n# Submodules\ngit submodule add <repo-url> <path> // Add submodule\ngit submodule init // Initialize submodules\ngit submodule update // Update submodules\ngit submodule update --remote // Update to latest remote commit\ngit submodule deinit <path> // Deinitialize submodule\ngit rm <path> // Remove submodule\n\n# Clean up\ngit clean -f // Remove untracked files\ngit gc // Garbage collection and optimization\n\n# Git Hooks (via Husky or .git/hooks)\n// Setup via scripts - automated actions on Git events\n\n# Misc\ngit help <command> // Get help for specific command</code></pre>",
    "category": "Git",
    "difficulty": "Intermediate"
  },
  {
    "id": 147,
    "question": "What is the difference between <code>shallow copy</code> and <code>deep copy</code> in ES6?",
    "answer": "<p><strong>Shallow Copy</strong></p><p>A shallow copy copies only the first level of an object or array. If the object has nested objects, the nested objects still refer to the same memory.<p><p><strong>Deep Copy</strong></p><p>A deep copy copies everything, including nested objects. So, changes to the copy do not affect the original.<p>",
    "category": "JavaScript",
    "difficulty": "Beginner"
  }
]